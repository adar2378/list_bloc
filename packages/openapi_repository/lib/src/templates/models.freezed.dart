// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

RepositoryTemplateModel _$RepositoryTemplateModelFromJson(
    Map<String, dynamic> json) {
  return _RepositoryTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$RepositoryTemplateModel {
  String get repositoryName => throw _privateConstructorUsedError;
  String get baseUrl => throw _privateConstructorUsedError;
  String get liveBasePath => throw _privateConstructorUsedError;
  List<AccessorModel> get accessors => throw _privateConstructorUsedError;
  int get connectTimeout => throw _privateConstructorUsedError;
  int get receiveTimeout => throw _privateConstructorUsedError;
  int get sendTimeout => throw _privateConstructorUsedError;
  String? get dioInterceptor => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RepositoryTemplateModelCopyWith<RepositoryTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RepositoryTemplateModelCopyWith<$Res> {
  factory $RepositoryTemplateModelCopyWith(RepositoryTemplateModel value,
          $Res Function(RepositoryTemplateModel) then) =
      _$RepositoryTemplateModelCopyWithImpl<$Res>;
  $Res call(
      {String repositoryName,
      String baseUrl,
      String liveBasePath,
      List<AccessorModel> accessors,
      int connectTimeout,
      int receiveTimeout,
      int sendTimeout,
      String? dioInterceptor});
}

/// @nodoc
class _$RepositoryTemplateModelCopyWithImpl<$Res>
    implements $RepositoryTemplateModelCopyWith<$Res> {
  _$RepositoryTemplateModelCopyWithImpl(this._value, this._then);

  final RepositoryTemplateModel _value;
  // ignore: unused_field
  final $Res Function(RepositoryTemplateModel) _then;

  @override
  $Res call({
    Object? repositoryName = freezed,
    Object? baseUrl = freezed,
    Object? liveBasePath = freezed,
    Object? accessors = freezed,
    Object? connectTimeout = freezed,
    Object? receiveTimeout = freezed,
    Object? sendTimeout = freezed,
    Object? dioInterceptor = freezed,
  }) {
    return _then(_value.copyWith(
      repositoryName: repositoryName == freezed
          ? _value.repositoryName
          : repositoryName // ignore: cast_nullable_to_non_nullable
              as String,
      baseUrl: baseUrl == freezed
          ? _value.baseUrl
          : baseUrl // ignore: cast_nullable_to_non_nullable
              as String,
      liveBasePath: liveBasePath == freezed
          ? _value.liveBasePath
          : liveBasePath // ignore: cast_nullable_to_non_nullable
              as String,
      accessors: accessors == freezed
          ? _value.accessors
          : accessors // ignore: cast_nullable_to_non_nullable
              as List<AccessorModel>,
      connectTimeout: connectTimeout == freezed
          ? _value.connectTimeout
          : connectTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      receiveTimeout: receiveTimeout == freezed
          ? _value.receiveTimeout
          : receiveTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      sendTimeout: sendTimeout == freezed
          ? _value.sendTimeout
          : sendTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      dioInterceptor: dioInterceptor == freezed
          ? _value.dioInterceptor
          : dioInterceptor // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$$_RepositoryTemplateModelCopyWith<$Res>
    implements $RepositoryTemplateModelCopyWith<$Res> {
  factory _$$_RepositoryTemplateModelCopyWith(_$_RepositoryTemplateModel value,
          $Res Function(_$_RepositoryTemplateModel) then) =
      __$$_RepositoryTemplateModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {String repositoryName,
      String baseUrl,
      String liveBasePath,
      List<AccessorModel> accessors,
      int connectTimeout,
      int receiveTimeout,
      int sendTimeout,
      String? dioInterceptor});
}

/// @nodoc
class __$$_RepositoryTemplateModelCopyWithImpl<$Res>
    extends _$RepositoryTemplateModelCopyWithImpl<$Res>
    implements _$$_RepositoryTemplateModelCopyWith<$Res> {
  __$$_RepositoryTemplateModelCopyWithImpl(_$_RepositoryTemplateModel _value,
      $Res Function(_$_RepositoryTemplateModel) _then)
      : super(_value, (v) => _then(v as _$_RepositoryTemplateModel));

  @override
  _$_RepositoryTemplateModel get _value =>
      super._value as _$_RepositoryTemplateModel;

  @override
  $Res call({
    Object? repositoryName = freezed,
    Object? baseUrl = freezed,
    Object? liveBasePath = freezed,
    Object? accessors = freezed,
    Object? connectTimeout = freezed,
    Object? receiveTimeout = freezed,
    Object? sendTimeout = freezed,
    Object? dioInterceptor = freezed,
  }) {
    return _then(_$_RepositoryTemplateModel(
      repositoryName: repositoryName == freezed
          ? _value.repositoryName
          : repositoryName // ignore: cast_nullable_to_non_nullable
              as String,
      baseUrl: baseUrl == freezed
          ? _value.baseUrl
          : baseUrl // ignore: cast_nullable_to_non_nullable
              as String,
      liveBasePath: liveBasePath == freezed
          ? _value.liveBasePath
          : liveBasePath // ignore: cast_nullable_to_non_nullable
              as String,
      accessors: accessors == freezed
          ? _value._accessors
          : accessors // ignore: cast_nullable_to_non_nullable
              as List<AccessorModel>,
      connectTimeout: connectTimeout == freezed
          ? _value.connectTimeout
          : connectTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      receiveTimeout: receiveTimeout == freezed
          ? _value.receiveTimeout
          : receiveTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      sendTimeout: sendTimeout == freezed
          ? _value.sendTimeout
          : sendTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      dioInterceptor: dioInterceptor == freezed
          ? _value.dioInterceptor
          : dioInterceptor // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$_RepositoryTemplateModel implements _RepositoryTemplateModel {
  const _$_RepositoryTemplateModel(
      {required this.repositoryName,
      required this.baseUrl,
      required this.liveBasePath,
      final List<AccessorModel> accessors = const [],
      required this.connectTimeout,
      required this.receiveTimeout,
      required this.sendTimeout,
      this.dioInterceptor})
      : _accessors = accessors;

  factory _$_RepositoryTemplateModel.fromJson(Map<String, dynamic> json) =>
      _$$_RepositoryTemplateModelFromJson(json);

  @override
  final String repositoryName;
  @override
  final String baseUrl;
  @override
  final String liveBasePath;
  final List<AccessorModel> _accessors;
  @override
  @JsonKey()
  List<AccessorModel> get accessors {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_accessors);
  }

  @override
  final int connectTimeout;
  @override
  final int receiveTimeout;
  @override
  final int sendTimeout;
  @override
  final String? dioInterceptor;

  @override
  String toString() {
    return 'RepositoryTemplateModel(repositoryName: $repositoryName, baseUrl: $baseUrl, liveBasePath: $liveBasePath, accessors: $accessors, connectTimeout: $connectTimeout, receiveTimeout: $receiveTimeout, sendTimeout: $sendTimeout, dioInterceptor: $dioInterceptor)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RepositoryTemplateModel &&
            const DeepCollectionEquality()
                .equals(other.repositoryName, repositoryName) &&
            const DeepCollectionEquality().equals(other.baseUrl, baseUrl) &&
            const DeepCollectionEquality()
                .equals(other.liveBasePath, liveBasePath) &&
            const DeepCollectionEquality()
                .equals(other._accessors, _accessors) &&
            const DeepCollectionEquality()
                .equals(other.connectTimeout, connectTimeout) &&
            const DeepCollectionEquality()
                .equals(other.receiveTimeout, receiveTimeout) &&
            const DeepCollectionEquality()
                .equals(other.sendTimeout, sendTimeout) &&
            const DeepCollectionEquality()
                .equals(other.dioInterceptor, dioInterceptor));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(repositoryName),
      const DeepCollectionEquality().hash(baseUrl),
      const DeepCollectionEquality().hash(liveBasePath),
      const DeepCollectionEquality().hash(_accessors),
      const DeepCollectionEquality().hash(connectTimeout),
      const DeepCollectionEquality().hash(receiveTimeout),
      const DeepCollectionEquality().hash(sendTimeout),
      const DeepCollectionEquality().hash(dioInterceptor));

  @JsonKey(ignore: true)
  @override
  _$$_RepositoryTemplateModelCopyWith<_$_RepositoryTemplateModel>
      get copyWith =>
          __$$_RepositoryTemplateModelCopyWithImpl<_$_RepositoryTemplateModel>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_RepositoryTemplateModelToJson(this);
  }
}

abstract class _RepositoryTemplateModel implements RepositoryTemplateModel {
  const factory _RepositoryTemplateModel(
      {required final String repositoryName,
      required final String baseUrl,
      required final String liveBasePath,
      final List<AccessorModel> accessors,
      required final int connectTimeout,
      required final int receiveTimeout,
      required final int sendTimeout,
      final String? dioInterceptor}) = _$_RepositoryTemplateModel;

  factory _RepositoryTemplateModel.fromJson(Map<String, dynamic> json) =
      _$_RepositoryTemplateModel.fromJson;

  @override
  String get repositoryName => throw _privateConstructorUsedError;
  @override
  String get baseUrl => throw _privateConstructorUsedError;
  @override
  String get liveBasePath => throw _privateConstructorUsedError;
  @override
  List<AccessorModel> get accessors => throw _privateConstructorUsedError;
  @override
  int get connectTimeout => throw _privateConstructorUsedError;
  @override
  int get receiveTimeout => throw _privateConstructorUsedError;
  @override
  int get sendTimeout => throw _privateConstructorUsedError;
  @override
  String? get dioInterceptor => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_RepositoryTemplateModelCopyWith<_$_RepositoryTemplateModel>
      get copyWith => throw _privateConstructorUsedError;
}

AccessorModel _$AccessorModelFromJson(Map<String, dynamic> json) {
  return _AccessorModel.fromJson(json);
}

/// @nodoc
mixin _$AccessorModel {
  String get type => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get methodName => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AccessorModelCopyWith<AccessorModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccessorModelCopyWith<$Res> {
  factory $AccessorModelCopyWith(
          AccessorModel value, $Res Function(AccessorModel) then) =
      _$AccessorModelCopyWithImpl<$Res>;
  $Res call({String type, String name, String methodName});
}

/// @nodoc
class _$AccessorModelCopyWithImpl<$Res>
    implements $AccessorModelCopyWith<$Res> {
  _$AccessorModelCopyWithImpl(this._value, this._then);

  final AccessorModel _value;
  // ignore: unused_field
  final $Res Function(AccessorModel) _then;

  @override
  $Res call({
    Object? type = freezed,
    Object? name = freezed,
    Object? methodName = freezed,
  }) {
    return _then(_value.copyWith(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      methodName: methodName == freezed
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_AccessorModelCopyWith<$Res>
    implements $AccessorModelCopyWith<$Res> {
  factory _$$_AccessorModelCopyWith(
          _$_AccessorModel value, $Res Function(_$_AccessorModel) then) =
      __$$_AccessorModelCopyWithImpl<$Res>;
  @override
  $Res call({String type, String name, String methodName});
}

/// @nodoc
class __$$_AccessorModelCopyWithImpl<$Res>
    extends _$AccessorModelCopyWithImpl<$Res>
    implements _$$_AccessorModelCopyWith<$Res> {
  __$$_AccessorModelCopyWithImpl(
      _$_AccessorModel _value, $Res Function(_$_AccessorModel) _then)
      : super(_value, (v) => _then(v as _$_AccessorModel));

  @override
  _$_AccessorModel get _value => super._value as _$_AccessorModel;

  @override
  $Res call({
    Object? type = freezed,
    Object? name = freezed,
    Object? methodName = freezed,
  }) {
    return _then(_$_AccessorModel(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      methodName: methodName == freezed
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AccessorModel implements _AccessorModel {
  const _$_AccessorModel(
      {required this.type, required this.name, required this.methodName});

  factory _$_AccessorModel.fromJson(Map<String, dynamic> json) =>
      _$$_AccessorModelFromJson(json);

  @override
  final String type;
  @override
  final String name;
  @override
  final String methodName;

  @override
  String toString() {
    return 'AccessorModel(type: $type, name: $name, methodName: $methodName)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AccessorModel &&
            const DeepCollectionEquality().equals(other.type, type) &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality()
                .equals(other.methodName, methodName));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(type),
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(methodName));

  @JsonKey(ignore: true)
  @override
  _$$_AccessorModelCopyWith<_$_AccessorModel> get copyWith =>
      __$$_AccessorModelCopyWithImpl<_$_AccessorModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AccessorModelToJson(this);
  }
}

abstract class _AccessorModel implements AccessorModel {
  const factory _AccessorModel(
      {required final String type,
      required final String name,
      required final String methodName}) = _$_AccessorModel;

  factory _AccessorModel.fromJson(Map<String, dynamic> json) =
      _$_AccessorModel.fromJson;

  @override
  String get type => throw _privateConstructorUsedError;
  @override
  String get name => throw _privateConstructorUsedError;
  @override
  String get methodName => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_AccessorModelCopyWith<_$_AccessorModel> get copyWith =>
      throw _privateConstructorUsedError;
}

FreezedTemplateModel _$FreezedTemplateModelFromJson(Map<String, dynamic> json) {
  return _FreezedTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$FreezedTemplateModel {
  String get name => throw _privateConstructorUsedError;
  bool get isPaginated => throw _privateConstructorUsedError;
  List<TypeModel> get types => throw _privateConstructorUsedError;
  bool get isTypesEmpty => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FreezedTemplateModelCopyWith<FreezedTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FreezedTemplateModelCopyWith<$Res> {
  factory $FreezedTemplateModelCopyWith(FreezedTemplateModel value,
          $Res Function(FreezedTemplateModel) then) =
      _$FreezedTemplateModelCopyWithImpl<$Res>;
  $Res call(
      {String name,
      bool isPaginated,
      List<TypeModel> types,
      bool isTypesEmpty});
}

/// @nodoc
class _$FreezedTemplateModelCopyWithImpl<$Res>
    implements $FreezedTemplateModelCopyWith<$Res> {
  _$FreezedTemplateModelCopyWithImpl(this._value, this._then);

  final FreezedTemplateModel _value;
  // ignore: unused_field
  final $Res Function(FreezedTemplateModel) _then;

  @override
  $Res call({
    Object? name = freezed,
    Object? isPaginated = freezed,
    Object? types = freezed,
    Object? isTypesEmpty = freezed,
  }) {
    return _then(_value.copyWith(
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      isPaginated: isPaginated == freezed
          ? _value.isPaginated
          : isPaginated // ignore: cast_nullable_to_non_nullable
              as bool,
      types: types == freezed
          ? _value.types
          : types // ignore: cast_nullable_to_non_nullable
              as List<TypeModel>,
      isTypesEmpty: isTypesEmpty == freezed
          ? _value.isTypesEmpty
          : isTypesEmpty // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$$_FreezedTemplateModelCopyWith<$Res>
    implements $FreezedTemplateModelCopyWith<$Res> {
  factory _$$_FreezedTemplateModelCopyWith(_$_FreezedTemplateModel value,
          $Res Function(_$_FreezedTemplateModel) then) =
      __$$_FreezedTemplateModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {String name,
      bool isPaginated,
      List<TypeModel> types,
      bool isTypesEmpty});
}

/// @nodoc
class __$$_FreezedTemplateModelCopyWithImpl<$Res>
    extends _$FreezedTemplateModelCopyWithImpl<$Res>
    implements _$$_FreezedTemplateModelCopyWith<$Res> {
  __$$_FreezedTemplateModelCopyWithImpl(_$_FreezedTemplateModel _value,
      $Res Function(_$_FreezedTemplateModel) _then)
      : super(_value, (v) => _then(v as _$_FreezedTemplateModel));

  @override
  _$_FreezedTemplateModel get _value => super._value as _$_FreezedTemplateModel;

  @override
  $Res call({
    Object? name = freezed,
    Object? isPaginated = freezed,
    Object? types = freezed,
    Object? isTypesEmpty = freezed,
  }) {
    return _then(_$_FreezedTemplateModel(
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      isPaginated: isPaginated == freezed
          ? _value.isPaginated
          : isPaginated // ignore: cast_nullable_to_non_nullable
              as bool,
      types: types == freezed
          ? _value._types
          : types // ignore: cast_nullable_to_non_nullable
              as List<TypeModel>,
      isTypesEmpty: isTypesEmpty == freezed
          ? _value.isTypesEmpty
          : isTypesEmpty // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$_FreezedTemplateModel implements _FreezedTemplateModel {
  const _$_FreezedTemplateModel(
      {required this.name,
      this.isPaginated = true,
      final List<TypeModel> types = const [],
      this.isTypesEmpty = false})
      : _types = types;

  factory _$_FreezedTemplateModel.fromJson(Map<String, dynamic> json) =>
      _$$_FreezedTemplateModelFromJson(json);

  @override
  final String name;
  @override
  @JsonKey()
  final bool isPaginated;
  final List<TypeModel> _types;
  @override
  @JsonKey()
  List<TypeModel> get types {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_types);
  }

  @override
  @JsonKey()
  final bool isTypesEmpty;

  @override
  String toString() {
    return 'FreezedTemplateModel(name: $name, isPaginated: $isPaginated, types: $types, isTypesEmpty: $isTypesEmpty)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FreezedTemplateModel &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality()
                .equals(other.isPaginated, isPaginated) &&
            const DeepCollectionEquality().equals(other._types, _types) &&
            const DeepCollectionEquality()
                .equals(other.isTypesEmpty, isTypesEmpty));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(isPaginated),
      const DeepCollectionEquality().hash(_types),
      const DeepCollectionEquality().hash(isTypesEmpty));

  @JsonKey(ignore: true)
  @override
  _$$_FreezedTemplateModelCopyWith<_$_FreezedTemplateModel> get copyWith =>
      __$$_FreezedTemplateModelCopyWithImpl<_$_FreezedTemplateModel>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_FreezedTemplateModelToJson(this);
  }
}

abstract class _FreezedTemplateModel implements FreezedTemplateModel {
  const factory _FreezedTemplateModel(
      {required final String name,
      final bool isPaginated,
      final List<TypeModel> types,
      final bool isTypesEmpty}) = _$_FreezedTemplateModel;

  factory _FreezedTemplateModel.fromJson(Map<String, dynamic> json) =
      _$_FreezedTemplateModel.fromJson;

  @override
  String get name => throw _privateConstructorUsedError;
  @override
  bool get isPaginated => throw _privateConstructorUsedError;
  @override
  List<TypeModel> get types => throw _privateConstructorUsedError;
  @override
  bool get isTypesEmpty => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_FreezedTemplateModelCopyWith<_$_FreezedTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

TypeModel _$TypeModelFromJson(Map<String, dynamic> json) {
  return _TypeModel.fromJson(json);
}

/// @nodoc
mixin _$TypeModel {
  bool get isRequired => throw _privateConstructorUsedError;
  bool get isNullable => throw _privateConstructorUsedError;
  String? get defaultValue => throw _privateConstructorUsedError;
  String get type => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TypeModelCopyWith<TypeModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TypeModelCopyWith<$Res> {
  factory $TypeModelCopyWith(TypeModel value, $Res Function(TypeModel) then) =
      _$TypeModelCopyWithImpl<$Res>;
  $Res call(
      {bool isRequired,
      bool isNullable,
      String? defaultValue,
      String type,
      String name});
}

/// @nodoc
class _$TypeModelCopyWithImpl<$Res> implements $TypeModelCopyWith<$Res> {
  _$TypeModelCopyWithImpl(this._value, this._then);

  final TypeModel _value;
  // ignore: unused_field
  final $Res Function(TypeModel) _then;

  @override
  $Res call({
    Object? isRequired = freezed,
    Object? isNullable = freezed,
    Object? defaultValue = freezed,
    Object? type = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      isRequired: isRequired == freezed
          ? _value.isRequired
          : isRequired // ignore: cast_nullable_to_non_nullable
              as bool,
      isNullable: isNullable == freezed
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
      defaultValue: defaultValue == freezed
          ? _value.defaultValue
          : defaultValue // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_TypeModelCopyWith<$Res> implements $TypeModelCopyWith<$Res> {
  factory _$$_TypeModelCopyWith(
          _$_TypeModel value, $Res Function(_$_TypeModel) then) =
      __$$_TypeModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {bool isRequired,
      bool isNullable,
      String? defaultValue,
      String type,
      String name});
}

/// @nodoc
class __$$_TypeModelCopyWithImpl<$Res> extends _$TypeModelCopyWithImpl<$Res>
    implements _$$_TypeModelCopyWith<$Res> {
  __$$_TypeModelCopyWithImpl(
      _$_TypeModel _value, $Res Function(_$_TypeModel) _then)
      : super(_value, (v) => _then(v as _$_TypeModel));

  @override
  _$_TypeModel get _value => super._value as _$_TypeModel;

  @override
  $Res call({
    Object? isRequired = freezed,
    Object? isNullable = freezed,
    Object? defaultValue = freezed,
    Object? type = freezed,
    Object? name = freezed,
  }) {
    return _then(_$_TypeModel(
      isRequired: isRequired == freezed
          ? _value.isRequired
          : isRequired // ignore: cast_nullable_to_non_nullable
              as bool,
      isNullable: isNullable == freezed
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
      defaultValue: defaultValue == freezed
          ? _value.defaultValue
          : defaultValue // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TypeModel implements _TypeModel {
  const _$_TypeModel(
      {required this.isRequired,
      required this.isNullable,
      this.defaultValue,
      required this.type,
      required this.name});

  factory _$_TypeModel.fromJson(Map<String, dynamic> json) =>
      _$$_TypeModelFromJson(json);

  @override
  final bool isRequired;
  @override
  final bool isNullable;
  @override
  final String? defaultValue;
  @override
  final String type;
  @override
  final String name;

  @override
  String toString() {
    return 'TypeModel(isRequired: $isRequired, isNullable: $isNullable, defaultValue: $defaultValue, type: $type, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TypeModel &&
            const DeepCollectionEquality()
                .equals(other.isRequired, isRequired) &&
            const DeepCollectionEquality()
                .equals(other.isNullable, isNullable) &&
            const DeepCollectionEquality()
                .equals(other.defaultValue, defaultValue) &&
            const DeepCollectionEquality().equals(other.type, type) &&
            const DeepCollectionEquality().equals(other.name, name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(isRequired),
      const DeepCollectionEquality().hash(isNullable),
      const DeepCollectionEquality().hash(defaultValue),
      const DeepCollectionEquality().hash(type),
      const DeepCollectionEquality().hash(name));

  @JsonKey(ignore: true)
  @override
  _$$_TypeModelCopyWith<_$_TypeModel> get copyWith =>
      __$$_TypeModelCopyWithImpl<_$_TypeModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TypeModelToJson(this);
  }
}

abstract class _TypeModel implements TypeModel {
  const factory _TypeModel(
      {required final bool isRequired,
      required final bool isNullable,
      final String? defaultValue,
      required final String type,
      required final String name}) = _$_TypeModel;

  factory _TypeModel.fromJson(Map<String, dynamic> json) =
      _$_TypeModel.fromJson;

  @override
  bool get isRequired => throw _privateConstructorUsedError;
  @override
  bool get isNullable => throw _privateConstructorUsedError;
  @override
  String? get defaultValue => throw _privateConstructorUsedError;
  @override
  String get type => throw _privateConstructorUsedError;
  @override
  String get name => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_TypeModelCopyWith<_$_TypeModel> get copyWith =>
      throw _privateConstructorUsedError;
}

TypedefTemplateModel _$TypedefTemplateModelFromJson(Map<String, dynamic> json) {
  return _TypedefTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$TypedefTemplateModel {
  String get type => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  bool get hasFilter => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TypedefTemplateModelCopyWith<TypedefTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TypedefTemplateModelCopyWith<$Res> {
  factory $TypedefTemplateModelCopyWith(TypedefTemplateModel value,
          $Res Function(TypedefTemplateModel) then) =
      _$TypedefTemplateModelCopyWithImpl<$Res>;
  $Res call({String type, String name, bool hasFilter});
}

/// @nodoc
class _$TypedefTemplateModelCopyWithImpl<$Res>
    implements $TypedefTemplateModelCopyWith<$Res> {
  _$TypedefTemplateModelCopyWithImpl(this._value, this._then);

  final TypedefTemplateModel _value;
  // ignore: unused_field
  final $Res Function(TypedefTemplateModel) _then;

  @override
  $Res call({
    Object? type = freezed,
    Object? name = freezed,
    Object? hasFilter = freezed,
  }) {
    return _then(_value.copyWith(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: hasFilter == freezed
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$$_TypedefTemplateModelCopyWith<$Res>
    implements $TypedefTemplateModelCopyWith<$Res> {
  factory _$$_TypedefTemplateModelCopyWith(_$_TypedefTemplateModel value,
          $Res Function(_$_TypedefTemplateModel) then) =
      __$$_TypedefTemplateModelCopyWithImpl<$Res>;
  @override
  $Res call({String type, String name, bool hasFilter});
}

/// @nodoc
class __$$_TypedefTemplateModelCopyWithImpl<$Res>
    extends _$TypedefTemplateModelCopyWithImpl<$Res>
    implements _$$_TypedefTemplateModelCopyWith<$Res> {
  __$$_TypedefTemplateModelCopyWithImpl(_$_TypedefTemplateModel _value,
      $Res Function(_$_TypedefTemplateModel) _then)
      : super(_value, (v) => _then(v as _$_TypedefTemplateModel));

  @override
  _$_TypedefTemplateModel get _value => super._value as _$_TypedefTemplateModel;

  @override
  $Res call({
    Object? type = freezed,
    Object? name = freezed,
    Object? hasFilter = freezed,
  }) {
    return _then(_$_TypedefTemplateModel(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: hasFilter == freezed
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TypedefTemplateModel implements _TypedefTemplateModel {
  const _$_TypedefTemplateModel(
      {required this.type, required this.name, this.hasFilter = false});

  factory _$_TypedefTemplateModel.fromJson(Map<String, dynamic> json) =>
      _$$_TypedefTemplateModelFromJson(json);

  @override
  final String type;
  @override
  final String name;
  @override
  @JsonKey()
  final bool hasFilter;

  @override
  String toString() {
    return 'TypedefTemplateModel(type: $type, name: $name, hasFilter: $hasFilter)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TypedefTemplateModel &&
            const DeepCollectionEquality().equals(other.type, type) &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality().equals(other.hasFilter, hasFilter));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(type),
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(hasFilter));

  @JsonKey(ignore: true)
  @override
  _$$_TypedefTemplateModelCopyWith<_$_TypedefTemplateModel> get copyWith =>
      __$$_TypedefTemplateModelCopyWithImpl<_$_TypedefTemplateModel>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TypedefTemplateModelToJson(this);
  }
}

abstract class _TypedefTemplateModel implements TypedefTemplateModel {
  const factory _TypedefTemplateModel(
      {required final String type,
      required final String name,
      final bool hasFilter}) = _$_TypedefTemplateModel;

  factory _TypedefTemplateModel.fromJson(Map<String, dynamic> json) =
      _$_TypedefTemplateModel.fromJson;

  @override
  String get type => throw _privateConstructorUsedError;
  @override
  String get name => throw _privateConstructorUsedError;
  @override
  bool get hasFilter => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_TypedefTemplateModelCopyWith<_$_TypedefTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

ListRepositoryTemplateModel _$ListRepositoryTemplateModelFromJson(
    Map<String, dynamic> json) {
  return _ListRepositoryTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$ListRepositoryTemplateModel {
  String get api => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  dynamic get hasRequiredParam => throw _privateConstructorUsedError;
  bool get isInline => throw _privateConstructorUsedError;
  List<MethodModel> get crudMethods => throw _privateConstructorUsedError;
  String get methodName => throw _privateConstructorUsedError;
  String get returnType => throw _privateConstructorUsedError;
  bool get hasFilter => throw _privateConstructorUsedError;
  List<ParamModel> get additionalParams => throw _privateConstructorUsedError;
  List<ParamModel> get filterParams => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListRepositoryTemplateModelCopyWith<ListRepositoryTemplateModel>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListRepositoryTemplateModelCopyWith<$Res> {
  factory $ListRepositoryTemplateModelCopyWith(
          ListRepositoryTemplateModel value,
          $Res Function(ListRepositoryTemplateModel) then) =
      _$ListRepositoryTemplateModelCopyWithImpl<$Res>;
  $Res call(
      {String api,
      String name,
      dynamic hasRequiredParam,
      bool isInline,
      List<MethodModel> crudMethods,
      String methodName,
      String returnType,
      bool hasFilter,
      List<ParamModel> additionalParams,
      List<ParamModel> filterParams});
}

/// @nodoc
class _$ListRepositoryTemplateModelCopyWithImpl<$Res>
    implements $ListRepositoryTemplateModelCopyWith<$Res> {
  _$ListRepositoryTemplateModelCopyWithImpl(this._value, this._then);

  final ListRepositoryTemplateModel _value;
  // ignore: unused_field
  final $Res Function(ListRepositoryTemplateModel) _then;

  @override
  $Res call({
    Object? api = freezed,
    Object? name = freezed,
    Object? hasRequiredParam = freezed,
    Object? isInline = freezed,
    Object? crudMethods = freezed,
    Object? methodName = freezed,
    Object? returnType = freezed,
    Object? hasFilter = freezed,
    Object? additionalParams = freezed,
    Object? filterParams = freezed,
  }) {
    return _then(_value.copyWith(
      api: api == freezed
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasRequiredParam: hasRequiredParam == freezed
          ? _value.hasRequiredParam
          : hasRequiredParam // ignore: cast_nullable_to_non_nullable
              as dynamic,
      isInline: isInline == freezed
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
      crudMethods: crudMethods == freezed
          ? _value.crudMethods
          : crudMethods // ignore: cast_nullable_to_non_nullable
              as List<MethodModel>,
      methodName: methodName == freezed
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: hasFilter == freezed
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      additionalParams: additionalParams == freezed
          ? _value.additionalParams
          : additionalParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      filterParams: filterParams == freezed
          ? _value.filterParams
          : filterParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
    ));
  }
}

/// @nodoc
abstract class _$$_ListRepositoryTemplateModelCopyWith<$Res>
    implements $ListRepositoryTemplateModelCopyWith<$Res> {
  factory _$$_ListRepositoryTemplateModelCopyWith(
          _$_ListRepositoryTemplateModel value,
          $Res Function(_$_ListRepositoryTemplateModel) then) =
      __$$_ListRepositoryTemplateModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {String api,
      String name,
      dynamic hasRequiredParam,
      bool isInline,
      List<MethodModel> crudMethods,
      String methodName,
      String returnType,
      bool hasFilter,
      List<ParamModel> additionalParams,
      List<ParamModel> filterParams});
}

/// @nodoc
class __$$_ListRepositoryTemplateModelCopyWithImpl<$Res>
    extends _$ListRepositoryTemplateModelCopyWithImpl<$Res>
    implements _$$_ListRepositoryTemplateModelCopyWith<$Res> {
  __$$_ListRepositoryTemplateModelCopyWithImpl(
      _$_ListRepositoryTemplateModel _value,
      $Res Function(_$_ListRepositoryTemplateModel) _then)
      : super(_value, (v) => _then(v as _$_ListRepositoryTemplateModel));

  @override
  _$_ListRepositoryTemplateModel get _value =>
      super._value as _$_ListRepositoryTemplateModel;

  @override
  $Res call({
    Object? api = freezed,
    Object? name = freezed,
    Object? hasRequiredParam = freezed,
    Object? isInline = freezed,
    Object? crudMethods = freezed,
    Object? methodName = freezed,
    Object? returnType = freezed,
    Object? hasFilter = freezed,
    Object? additionalParams = freezed,
    Object? filterParams = freezed,
  }) {
    return _then(_$_ListRepositoryTemplateModel(
      api: api == freezed
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasRequiredParam: hasRequiredParam == freezed
          ? _value.hasRequiredParam
          : hasRequiredParam,
      isInline: isInline == freezed
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
      crudMethods: crudMethods == freezed
          ? _value._crudMethods
          : crudMethods // ignore: cast_nullable_to_non_nullable
              as List<MethodModel>,
      methodName: methodName == freezed
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: hasFilter == freezed
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      additionalParams: additionalParams == freezed
          ? _value._additionalParams
          : additionalParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      filterParams: filterParams == freezed
          ? _value._filterParams
          : filterParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$_ListRepositoryTemplateModel implements _ListRepositoryTemplateModel {
  const _$_ListRepositoryTemplateModel(
      {required this.api,
      required this.name,
      this.hasRequiredParam = false,
      this.isInline = false,
      required final List<MethodModel> crudMethods,
      required this.methodName,
      required this.returnType,
      this.hasFilter = false,
      final List<ParamModel> additionalParams = const [],
      final List<ParamModel> filterParams = const []})
      : _crudMethods = crudMethods,
        _additionalParams = additionalParams,
        _filterParams = filterParams;

  factory _$_ListRepositoryTemplateModel.fromJson(Map<String, dynamic> json) =>
      _$$_ListRepositoryTemplateModelFromJson(json);

  @override
  final String api;
  @override
  final String name;
  @override
  @JsonKey()
  final dynamic hasRequiredParam;
  @override
  @JsonKey()
  final bool isInline;
  final List<MethodModel> _crudMethods;
  @override
  List<MethodModel> get crudMethods {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_crudMethods);
  }

  @override
  final String methodName;
  @override
  final String returnType;
  @override
  @JsonKey()
  final bool hasFilter;
  final List<ParamModel> _additionalParams;
  @override
  @JsonKey()
  List<ParamModel> get additionalParams {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_additionalParams);
  }

  final List<ParamModel> _filterParams;
  @override
  @JsonKey()
  List<ParamModel> get filterParams {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filterParams);
  }

  @override
  String toString() {
    return 'ListRepositoryTemplateModel(api: $api, name: $name, hasRequiredParam: $hasRequiredParam, isInline: $isInline, crudMethods: $crudMethods, methodName: $methodName, returnType: $returnType, hasFilter: $hasFilter, additionalParams: $additionalParams, filterParams: $filterParams)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ListRepositoryTemplateModel &&
            const DeepCollectionEquality().equals(other.api, api) &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality()
                .equals(other.hasRequiredParam, hasRequiredParam) &&
            const DeepCollectionEquality().equals(other.isInline, isInline) &&
            const DeepCollectionEquality()
                .equals(other._crudMethods, _crudMethods) &&
            const DeepCollectionEquality()
                .equals(other.methodName, methodName) &&
            const DeepCollectionEquality()
                .equals(other.returnType, returnType) &&
            const DeepCollectionEquality().equals(other.hasFilter, hasFilter) &&
            const DeepCollectionEquality()
                .equals(other._additionalParams, _additionalParams) &&
            const DeepCollectionEquality()
                .equals(other._filterParams, _filterParams));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(api),
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(hasRequiredParam),
      const DeepCollectionEquality().hash(isInline),
      const DeepCollectionEquality().hash(_crudMethods),
      const DeepCollectionEquality().hash(methodName),
      const DeepCollectionEquality().hash(returnType),
      const DeepCollectionEquality().hash(hasFilter),
      const DeepCollectionEquality().hash(_additionalParams),
      const DeepCollectionEquality().hash(_filterParams));

  @JsonKey(ignore: true)
  @override
  _$$_ListRepositoryTemplateModelCopyWith<_$_ListRepositoryTemplateModel>
      get copyWith => __$$_ListRepositoryTemplateModelCopyWithImpl<
          _$_ListRepositoryTemplateModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ListRepositoryTemplateModelToJson(this);
  }
}

abstract class _ListRepositoryTemplateModel
    implements ListRepositoryTemplateModel {
  const factory _ListRepositoryTemplateModel(
      {required final String api,
      required final String name,
      final dynamic hasRequiredParam,
      final bool isInline,
      required final List<MethodModel> crudMethods,
      required final String methodName,
      required final String returnType,
      final bool hasFilter,
      final List<ParamModel> additionalParams,
      final List<ParamModel> filterParams}) = _$_ListRepositoryTemplateModel;

  factory _ListRepositoryTemplateModel.fromJson(Map<String, dynamic> json) =
      _$_ListRepositoryTemplateModel.fromJson;

  @override
  String get api => throw _privateConstructorUsedError;
  @override
  String get name => throw _privateConstructorUsedError;
  @override
  dynamic get hasRequiredParam => throw _privateConstructorUsedError;
  @override
  bool get isInline => throw _privateConstructorUsedError;
  @override
  List<MethodModel> get crudMethods => throw _privateConstructorUsedError;
  @override
  String get methodName => throw _privateConstructorUsedError;
  @override
  String get returnType => throw _privateConstructorUsedError;
  @override
  bool get hasFilter => throw _privateConstructorUsedError;
  @override
  List<ParamModel> get additionalParams => throw _privateConstructorUsedError;
  @override
  List<ParamModel> get filterParams => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_ListRepositoryTemplateModelCopyWith<_$_ListRepositoryTemplateModel>
      get copyWith => throw _privateConstructorUsedError;
}

DataCubitTemplateModel _$DataCubitTemplateModelFromJson(
    Map<String, dynamic> json) {
  return _DataCubitTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$DataCubitTemplateModel {
  String get api => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  dynamic get hasRequiredParam => throw _privateConstructorUsedError;
  bool get isInline => throw _privateConstructorUsedError;
  List<MethodModel> get crudMethods => throw _privateConstructorUsedError;
  String get methodName => throw _privateConstructorUsedError;
  String get returnType => throw _privateConstructorUsedError;
  List<ParamModel> get additionalParams => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $DataCubitTemplateModelCopyWith<DataCubitTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DataCubitTemplateModelCopyWith<$Res> {
  factory $DataCubitTemplateModelCopyWith(DataCubitTemplateModel value,
          $Res Function(DataCubitTemplateModel) then) =
      _$DataCubitTemplateModelCopyWithImpl<$Res>;
  $Res call(
      {String api,
      String name,
      dynamic hasRequiredParam,
      bool isInline,
      List<MethodModel> crudMethods,
      String methodName,
      String returnType,
      List<ParamModel> additionalParams});
}

/// @nodoc
class _$DataCubitTemplateModelCopyWithImpl<$Res>
    implements $DataCubitTemplateModelCopyWith<$Res> {
  _$DataCubitTemplateModelCopyWithImpl(this._value, this._then);

  final DataCubitTemplateModel _value;
  // ignore: unused_field
  final $Res Function(DataCubitTemplateModel) _then;

  @override
  $Res call({
    Object? api = freezed,
    Object? name = freezed,
    Object? hasRequiredParam = freezed,
    Object? isInline = freezed,
    Object? crudMethods = freezed,
    Object? methodName = freezed,
    Object? returnType = freezed,
    Object? additionalParams = freezed,
  }) {
    return _then(_value.copyWith(
      api: api == freezed
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasRequiredParam: hasRequiredParam == freezed
          ? _value.hasRequiredParam
          : hasRequiredParam // ignore: cast_nullable_to_non_nullable
              as dynamic,
      isInline: isInline == freezed
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
      crudMethods: crudMethods == freezed
          ? _value.crudMethods
          : crudMethods // ignore: cast_nullable_to_non_nullable
              as List<MethodModel>,
      methodName: methodName == freezed
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      additionalParams: additionalParams == freezed
          ? _value.additionalParams
          : additionalParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
    ));
  }
}

/// @nodoc
abstract class _$$_DataCubitTemplateModelCopyWith<$Res>
    implements $DataCubitTemplateModelCopyWith<$Res> {
  factory _$$_DataCubitTemplateModelCopyWith(_$_DataCubitTemplateModel value,
          $Res Function(_$_DataCubitTemplateModel) then) =
      __$$_DataCubitTemplateModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {String api,
      String name,
      dynamic hasRequiredParam,
      bool isInline,
      List<MethodModel> crudMethods,
      String methodName,
      String returnType,
      List<ParamModel> additionalParams});
}

/// @nodoc
class __$$_DataCubitTemplateModelCopyWithImpl<$Res>
    extends _$DataCubitTemplateModelCopyWithImpl<$Res>
    implements _$$_DataCubitTemplateModelCopyWith<$Res> {
  __$$_DataCubitTemplateModelCopyWithImpl(_$_DataCubitTemplateModel _value,
      $Res Function(_$_DataCubitTemplateModel) _then)
      : super(_value, (v) => _then(v as _$_DataCubitTemplateModel));

  @override
  _$_DataCubitTemplateModel get _value =>
      super._value as _$_DataCubitTemplateModel;

  @override
  $Res call({
    Object? api = freezed,
    Object? name = freezed,
    Object? hasRequiredParam = freezed,
    Object? isInline = freezed,
    Object? crudMethods = freezed,
    Object? methodName = freezed,
    Object? returnType = freezed,
    Object? additionalParams = freezed,
  }) {
    return _then(_$_DataCubitTemplateModel(
      api: api == freezed
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasRequiredParam: hasRequiredParam == freezed
          ? _value.hasRequiredParam
          : hasRequiredParam,
      isInline: isInline == freezed
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
      crudMethods: crudMethods == freezed
          ? _value._crudMethods
          : crudMethods // ignore: cast_nullable_to_non_nullable
              as List<MethodModel>,
      methodName: methodName == freezed
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      additionalParams: additionalParams == freezed
          ? _value._additionalParams
          : additionalParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$_DataCubitTemplateModel implements _DataCubitTemplateModel {
  const _$_DataCubitTemplateModel(
      {required this.api,
      required this.name,
      this.hasRequiredParam = false,
      this.isInline = false,
      required final List<MethodModel> crudMethods,
      required this.methodName,
      required this.returnType,
      final List<ParamModel> additionalParams = const []})
      : _crudMethods = crudMethods,
        _additionalParams = additionalParams;

  factory _$_DataCubitTemplateModel.fromJson(Map<String, dynamic> json) =>
      _$$_DataCubitTemplateModelFromJson(json);

  @override
  final String api;
  @override
  final String name;
  @override
  @JsonKey()
  final dynamic hasRequiredParam;
  @override
  @JsonKey()
  final bool isInline;
  final List<MethodModel> _crudMethods;
  @override
  List<MethodModel> get crudMethods {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_crudMethods);
  }

  @override
  final String methodName;
  @override
  final String returnType;
  final List<ParamModel> _additionalParams;
  @override
  @JsonKey()
  List<ParamModel> get additionalParams {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_additionalParams);
  }

  @override
  String toString() {
    return 'DataCubitTemplateModel(api: $api, name: $name, hasRequiredParam: $hasRequiredParam, isInline: $isInline, crudMethods: $crudMethods, methodName: $methodName, returnType: $returnType, additionalParams: $additionalParams)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DataCubitTemplateModel &&
            const DeepCollectionEquality().equals(other.api, api) &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality()
                .equals(other.hasRequiredParam, hasRequiredParam) &&
            const DeepCollectionEquality().equals(other.isInline, isInline) &&
            const DeepCollectionEquality()
                .equals(other._crudMethods, _crudMethods) &&
            const DeepCollectionEquality()
                .equals(other.methodName, methodName) &&
            const DeepCollectionEquality()
                .equals(other.returnType, returnType) &&
            const DeepCollectionEquality()
                .equals(other._additionalParams, _additionalParams));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(api),
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(hasRequiredParam),
      const DeepCollectionEquality().hash(isInline),
      const DeepCollectionEquality().hash(_crudMethods),
      const DeepCollectionEquality().hash(methodName),
      const DeepCollectionEquality().hash(returnType),
      const DeepCollectionEquality().hash(_additionalParams));

  @JsonKey(ignore: true)
  @override
  _$$_DataCubitTemplateModelCopyWith<_$_DataCubitTemplateModel> get copyWith =>
      __$$_DataCubitTemplateModelCopyWithImpl<_$_DataCubitTemplateModel>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_DataCubitTemplateModelToJson(this);
  }
}

abstract class _DataCubitTemplateModel implements DataCubitTemplateModel {
  const factory _DataCubitTemplateModel(
      {required final String api,
      required final String name,
      final dynamic hasRequiredParam,
      final bool isInline,
      required final List<MethodModel> crudMethods,
      required final String methodName,
      required final String returnType,
      final List<ParamModel> additionalParams}) = _$_DataCubitTemplateModel;

  factory _DataCubitTemplateModel.fromJson(Map<String, dynamic> json) =
      _$_DataCubitTemplateModel.fromJson;

  @override
  String get api => throw _privateConstructorUsedError;
  @override
  String get name => throw _privateConstructorUsedError;
  @override
  dynamic get hasRequiredParam => throw _privateConstructorUsedError;
  @override
  bool get isInline => throw _privateConstructorUsedError;
  @override
  List<MethodModel> get crudMethods => throw _privateConstructorUsedError;
  @override
  String get methodName => throw _privateConstructorUsedError;
  @override
  String get returnType => throw _privateConstructorUsedError;
  @override
  List<ParamModel> get additionalParams => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_DataCubitTemplateModelCopyWith<_$_DataCubitTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

ParamModel _$ParamModelFromJson(Map<String, dynamic> json) {
  return _ParamModel.fromJson(json);
}

/// @nodoc
mixin _$ParamModel {
  String get param => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ParamModelCopyWith<ParamModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ParamModelCopyWith<$Res> {
  factory $ParamModelCopyWith(
          ParamModel value, $Res Function(ParamModel) then) =
      _$ParamModelCopyWithImpl<$Res>;
  $Res call({String param});
}

/// @nodoc
class _$ParamModelCopyWithImpl<$Res> implements $ParamModelCopyWith<$Res> {
  _$ParamModelCopyWithImpl(this._value, this._then);

  final ParamModel _value;
  // ignore: unused_field
  final $Res Function(ParamModel) _then;

  @override
  $Res call({
    Object? param = freezed,
  }) {
    return _then(_value.copyWith(
      param: param == freezed
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_ParamModelCopyWith<$Res>
    implements $ParamModelCopyWith<$Res> {
  factory _$$_ParamModelCopyWith(
          _$_ParamModel value, $Res Function(_$_ParamModel) then) =
      __$$_ParamModelCopyWithImpl<$Res>;
  @override
  $Res call({String param});
}

/// @nodoc
class __$$_ParamModelCopyWithImpl<$Res> extends _$ParamModelCopyWithImpl<$Res>
    implements _$$_ParamModelCopyWith<$Res> {
  __$$_ParamModelCopyWithImpl(
      _$_ParamModel _value, $Res Function(_$_ParamModel) _then)
      : super(_value, (v) => _then(v as _$_ParamModel));

  @override
  _$_ParamModel get _value => super._value as _$_ParamModel;

  @override
  $Res call({
    Object? param = freezed,
  }) {
    return _then(_$_ParamModel(
      param == freezed
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ParamModel implements _ParamModel {
  const _$_ParamModel(this.param);

  factory _$_ParamModel.fromJson(Map<String, dynamic> json) =>
      _$$_ParamModelFromJson(json);

  @override
  final String param;

  @override
  String toString() {
    return 'ParamModel(param: $param)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ParamModel &&
            const DeepCollectionEquality().equals(other.param, param));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(param));

  @JsonKey(ignore: true)
  @override
  _$$_ParamModelCopyWith<_$_ParamModel> get copyWith =>
      __$$_ParamModelCopyWithImpl<_$_ParamModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ParamModelToJson(this);
  }
}

abstract class _ParamModel implements ParamModel {
  const factory _ParamModel(final String param) = _$_ParamModel;

  factory _ParamModel.fromJson(Map<String, dynamic> json) =
      _$_ParamModel.fromJson;

  @override
  String get param => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_ParamModelCopyWith<_$_ParamModel> get copyWith =>
      throw _privateConstructorUsedError;
}

ArgModel _$ArgModelFromJson(Map<String, dynamic> json) {
  return _ArgModelModel.fromJson(json);
}

/// @nodoc
mixin _$ArgModel {
  String get argType => throw _privateConstructorUsedError;
  String get argName => throw _privateConstructorUsedError;
  bool get isNullableArg => throw _privateConstructorUsedError;
  bool get isRequiredArg => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ArgModelCopyWith<ArgModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ArgModelCopyWith<$Res> {
  factory $ArgModelCopyWith(ArgModel value, $Res Function(ArgModel) then) =
      _$ArgModelCopyWithImpl<$Res>;
  $Res call(
      {String argType, String argName, bool isNullableArg, bool isRequiredArg});
}

/// @nodoc
class _$ArgModelCopyWithImpl<$Res> implements $ArgModelCopyWith<$Res> {
  _$ArgModelCopyWithImpl(this._value, this._then);

  final ArgModel _value;
  // ignore: unused_field
  final $Res Function(ArgModel) _then;

  @override
  $Res call({
    Object? argType = freezed,
    Object? argName = freezed,
    Object? isNullableArg = freezed,
    Object? isRequiredArg = freezed,
  }) {
    return _then(_value.copyWith(
      argType: argType == freezed
          ? _value.argType
          : argType // ignore: cast_nullable_to_non_nullable
              as String,
      argName: argName == freezed
          ? _value.argName
          : argName // ignore: cast_nullable_to_non_nullable
              as String,
      isNullableArg: isNullableArg == freezed
          ? _value.isNullableArg
          : isNullableArg // ignore: cast_nullable_to_non_nullable
              as bool,
      isRequiredArg: isRequiredArg == freezed
          ? _value.isRequiredArg
          : isRequiredArg // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$$_ArgModelModelCopyWith<$Res>
    implements $ArgModelCopyWith<$Res> {
  factory _$$_ArgModelModelCopyWith(
          _$_ArgModelModel value, $Res Function(_$_ArgModelModel) then) =
      __$$_ArgModelModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {String argType, String argName, bool isNullableArg, bool isRequiredArg});
}

/// @nodoc
class __$$_ArgModelModelCopyWithImpl<$Res> extends _$ArgModelCopyWithImpl<$Res>
    implements _$$_ArgModelModelCopyWith<$Res> {
  __$$_ArgModelModelCopyWithImpl(
      _$_ArgModelModel _value, $Res Function(_$_ArgModelModel) _then)
      : super(_value, (v) => _then(v as _$_ArgModelModel));

  @override
  _$_ArgModelModel get _value => super._value as _$_ArgModelModel;

  @override
  $Res call({
    Object? argType = freezed,
    Object? argName = freezed,
    Object? isNullableArg = freezed,
    Object? isRequiredArg = freezed,
  }) {
    return _then(_$_ArgModelModel(
      argType == freezed
          ? _value.argType
          : argType // ignore: cast_nullable_to_non_nullable
              as String,
      argName == freezed
          ? _value.argName
          : argName // ignore: cast_nullable_to_non_nullable
              as String,
      isNullableArg == freezed
          ? _value.isNullableArg
          : isNullableArg // ignore: cast_nullable_to_non_nullable
              as bool,
      isRequiredArg == freezed
          ? _value.isRequiredArg
          : isRequiredArg // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ArgModelModel implements _ArgModelModel {
  const _$_ArgModelModel(
      this.argType, this.argName, this.isNullableArg, this.isRequiredArg);

  factory _$_ArgModelModel.fromJson(Map<String, dynamic> json) =>
      _$$_ArgModelModelFromJson(json);

  @override
  final String argType;
  @override
  final String argName;
  @override
  final bool isNullableArg;
  @override
  final bool isRequiredArg;

  @override
  String toString() {
    return 'ArgModel(argType: $argType, argName: $argName, isNullableArg: $isNullableArg, isRequiredArg: $isRequiredArg)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ArgModelModel &&
            const DeepCollectionEquality().equals(other.argType, argType) &&
            const DeepCollectionEquality().equals(other.argName, argName) &&
            const DeepCollectionEquality()
                .equals(other.isNullableArg, isNullableArg) &&
            const DeepCollectionEquality()
                .equals(other.isRequiredArg, isRequiredArg));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(argType),
      const DeepCollectionEquality().hash(argName),
      const DeepCollectionEquality().hash(isNullableArg),
      const DeepCollectionEquality().hash(isRequiredArg));

  @JsonKey(ignore: true)
  @override
  _$$_ArgModelModelCopyWith<_$_ArgModelModel> get copyWith =>
      __$$_ArgModelModelCopyWithImpl<_$_ArgModelModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ArgModelModelToJson(this);
  }
}

abstract class _ArgModelModel implements ArgModel {
  const factory _ArgModelModel(final String argType, final String argName,
      final bool isNullableArg, final bool isRequiredArg) = _$_ArgModelModel;

  factory _ArgModelModel.fromJson(Map<String, dynamic> json) =
      _$_ArgModelModel.fromJson;

  @override
  String get argType => throw _privateConstructorUsedError;
  @override
  String get argName => throw _privateConstructorUsedError;
  @override
  bool get isNullableArg => throw _privateConstructorUsedError;
  @override
  bool get isRequiredArg => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_ArgModelModelCopyWith<_$_ArgModelModel> get copyWith =>
      throw _privateConstructorUsedError;
}

MethodModel _$MethodModelFromJson(Map<String, dynamic> json) {
  return _MethodModel.fromJson(json);
}

/// @nodoc
mixin _$MethodModel {
  String get returnType => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get operation => throw _privateConstructorUsedError;
  List<ArgModel> get arguments => throw _privateConstructorUsedError;
  List<ParamModel> get parameters => throw _privateConstructorUsedError;
  bool get isEmptyArgs => throw _privateConstructorUsedError;
  bool get isList => throw _privateConstructorUsedError;
  bool get shouldDataBlocReload => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MethodModelCopyWith<MethodModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MethodModelCopyWith<$Res> {
  factory $MethodModelCopyWith(
          MethodModel value, $Res Function(MethodModel) then) =
      _$MethodModelCopyWithImpl<$Res>;
  $Res call(
      {String returnType,
      String name,
      String operation,
      List<ArgModel> arguments,
      List<ParamModel> parameters,
      bool isEmptyArgs,
      bool isList,
      bool shouldDataBlocReload});
}

/// @nodoc
class _$MethodModelCopyWithImpl<$Res> implements $MethodModelCopyWith<$Res> {
  _$MethodModelCopyWithImpl(this._value, this._then);

  final MethodModel _value;
  // ignore: unused_field
  final $Res Function(MethodModel) _then;

  @override
  $Res call({
    Object? returnType = freezed,
    Object? name = freezed,
    Object? operation = freezed,
    Object? arguments = freezed,
    Object? parameters = freezed,
    Object? isEmptyArgs = freezed,
    Object? isList = freezed,
    Object? shouldDataBlocReload = freezed,
  }) {
    return _then(_value.copyWith(
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      operation: operation == freezed
          ? _value.operation
          : operation // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: arguments == freezed
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as List<ArgModel>,
      parameters: parameters == freezed
          ? _value.parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      isEmptyArgs: isEmptyArgs == freezed
          ? _value.isEmptyArgs
          : isEmptyArgs // ignore: cast_nullable_to_non_nullable
              as bool,
      isList: isList == freezed
          ? _value.isList
          : isList // ignore: cast_nullable_to_non_nullable
              as bool,
      shouldDataBlocReload: shouldDataBlocReload == freezed
          ? _value.shouldDataBlocReload
          : shouldDataBlocReload // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$$_MethodModelCopyWith<$Res>
    implements $MethodModelCopyWith<$Res> {
  factory _$$_MethodModelCopyWith(
          _$_MethodModel value, $Res Function(_$_MethodModel) then) =
      __$$_MethodModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {String returnType,
      String name,
      String operation,
      List<ArgModel> arguments,
      List<ParamModel> parameters,
      bool isEmptyArgs,
      bool isList,
      bool shouldDataBlocReload});
}

/// @nodoc
class __$$_MethodModelCopyWithImpl<$Res> extends _$MethodModelCopyWithImpl<$Res>
    implements _$$_MethodModelCopyWith<$Res> {
  __$$_MethodModelCopyWithImpl(
      _$_MethodModel _value, $Res Function(_$_MethodModel) _then)
      : super(_value, (v) => _then(v as _$_MethodModel));

  @override
  _$_MethodModel get _value => super._value as _$_MethodModel;

  @override
  $Res call({
    Object? returnType = freezed,
    Object? name = freezed,
    Object? operation = freezed,
    Object? arguments = freezed,
    Object? parameters = freezed,
    Object? isEmptyArgs = freezed,
    Object? isList = freezed,
    Object? shouldDataBlocReload = freezed,
  }) {
    return _then(_$_MethodModel(
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      operation: operation == freezed
          ? _value.operation
          : operation // ignore: cast_nullable_to_non_nullable
              as String,
      arguments: arguments == freezed
          ? _value._arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as List<ArgModel>,
      parameters: parameters == freezed
          ? _value._parameters
          : parameters // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      isEmptyArgs: isEmptyArgs == freezed
          ? _value.isEmptyArgs
          : isEmptyArgs // ignore: cast_nullable_to_non_nullable
              as bool,
      isList: isList == freezed
          ? _value.isList
          : isList // ignore: cast_nullable_to_non_nullable
              as bool,
      shouldDataBlocReload: shouldDataBlocReload == freezed
          ? _value.shouldDataBlocReload
          : shouldDataBlocReload // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$_MethodModel implements _MethodModel {
  const _$_MethodModel(
      {required this.returnType,
      required this.name,
      required this.operation,
      required final List<ArgModel> arguments,
      required final List<ParamModel> parameters,
      this.isEmptyArgs = false,
      this.isList = false,
      this.shouldDataBlocReload = true})
      : _arguments = arguments,
        _parameters = parameters;

  factory _$_MethodModel.fromJson(Map<String, dynamic> json) =>
      _$$_MethodModelFromJson(json);

  @override
  final String returnType;
  @override
  final String name;
  @override
  final String operation;
  final List<ArgModel> _arguments;
  @override
  List<ArgModel> get arguments {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_arguments);
  }

  final List<ParamModel> _parameters;
  @override
  List<ParamModel> get parameters {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_parameters);
  }

  @override
  @JsonKey()
  final bool isEmptyArgs;
  @override
  @JsonKey()
  final bool isList;
  @override
  @JsonKey()
  final bool shouldDataBlocReload;

  @override
  String toString() {
    return 'MethodModel(returnType: $returnType, name: $name, operation: $operation, arguments: $arguments, parameters: $parameters, isEmptyArgs: $isEmptyArgs, isList: $isList, shouldDataBlocReload: $shouldDataBlocReload)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MethodModel &&
            const DeepCollectionEquality()
                .equals(other.returnType, returnType) &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality().equals(other.operation, operation) &&
            const DeepCollectionEquality()
                .equals(other._arguments, _arguments) &&
            const DeepCollectionEquality()
                .equals(other._parameters, _parameters) &&
            const DeepCollectionEquality()
                .equals(other.isEmptyArgs, isEmptyArgs) &&
            const DeepCollectionEquality().equals(other.isList, isList) &&
            const DeepCollectionEquality()
                .equals(other.shouldDataBlocReload, shouldDataBlocReload));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(returnType),
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(operation),
      const DeepCollectionEquality().hash(_arguments),
      const DeepCollectionEquality().hash(_parameters),
      const DeepCollectionEquality().hash(isEmptyArgs),
      const DeepCollectionEquality().hash(isList),
      const DeepCollectionEquality().hash(shouldDataBlocReload));

  @JsonKey(ignore: true)
  @override
  _$$_MethodModelCopyWith<_$_MethodModel> get copyWith =>
      __$$_MethodModelCopyWithImpl<_$_MethodModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MethodModelToJson(this);
  }
}

abstract class _MethodModel implements MethodModel {
  const factory _MethodModel(
      {required final String returnType,
      required final String name,
      required final String operation,
      required final List<ArgModel> arguments,
      required final List<ParamModel> parameters,
      final bool isEmptyArgs,
      final bool isList,
      final bool shouldDataBlocReload}) = _$_MethodModel;

  factory _MethodModel.fromJson(Map<String, dynamic> json) =
      _$_MethodModel.fromJson;

  @override
  String get returnType => throw _privateConstructorUsedError;
  @override
  String get name => throw _privateConstructorUsedError;
  @override
  String get operation => throw _privateConstructorUsedError;
  @override
  List<ArgModel> get arguments => throw _privateConstructorUsedError;
  @override
  List<ParamModel> get parameters => throw _privateConstructorUsedError;
  @override
  bool get isEmptyArgs => throw _privateConstructorUsedError;
  @override
  bool get isList => throw _privateConstructorUsedError;
  @override
  bool get shouldDataBlocReload => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_MethodModelCopyWith<_$_MethodModel> get copyWith =>
      throw _privateConstructorUsedError;
}

LoaderMethodModel _$LoaderMethodModelFromJson(Map<String, dynamic> json) {
  return _LoaderMethodModel.fromJson(json);
}

/// @nodoc
mixin _$LoaderMethodModel {
  String get returnType => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  bool get hasFilter => throw _privateConstructorUsedError;
  bool get isListLoader => throw _privateConstructorUsedError;
  bool get isPaginated => throw _privateConstructorUsedError;
  bool get hasRequiredParam => throw _privateConstructorUsedError;
  List<TypeModel> get types => throw _privateConstructorUsedError;
  List<ParamModel> get filterParams => throw _privateConstructorUsedError;
  int get defaultOffset => throw _privateConstructorUsedError;
  int get defaultPageSize => throw _privateConstructorUsedError;
  bool get isInline => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LoaderMethodModelCopyWith<LoaderMethodModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoaderMethodModelCopyWith<$Res> {
  factory $LoaderMethodModelCopyWith(
          LoaderMethodModel value, $Res Function(LoaderMethodModel) then) =
      _$LoaderMethodModelCopyWithImpl<$Res>;
  $Res call(
      {String returnType,
      String name,
      bool hasFilter,
      bool isListLoader,
      bool isPaginated,
      bool hasRequiredParam,
      List<TypeModel> types,
      List<ParamModel> filterParams,
      int defaultOffset,
      int defaultPageSize,
      bool isInline});
}

/// @nodoc
class _$LoaderMethodModelCopyWithImpl<$Res>
    implements $LoaderMethodModelCopyWith<$Res> {
  _$LoaderMethodModelCopyWithImpl(this._value, this._then);

  final LoaderMethodModel _value;
  // ignore: unused_field
  final $Res Function(LoaderMethodModel) _then;

  @override
  $Res call({
    Object? returnType = freezed,
    Object? name = freezed,
    Object? hasFilter = freezed,
    Object? isListLoader = freezed,
    Object? isPaginated = freezed,
    Object? hasRequiredParam = freezed,
    Object? types = freezed,
    Object? filterParams = freezed,
    Object? defaultOffset = freezed,
    Object? defaultPageSize = freezed,
    Object? isInline = freezed,
  }) {
    return _then(_value.copyWith(
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: hasFilter == freezed
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      isListLoader: isListLoader == freezed
          ? _value.isListLoader
          : isListLoader // ignore: cast_nullable_to_non_nullable
              as bool,
      isPaginated: isPaginated == freezed
          ? _value.isPaginated
          : isPaginated // ignore: cast_nullable_to_non_nullable
              as bool,
      hasRequiredParam: hasRequiredParam == freezed
          ? _value.hasRequiredParam
          : hasRequiredParam // ignore: cast_nullable_to_non_nullable
              as bool,
      types: types == freezed
          ? _value.types
          : types // ignore: cast_nullable_to_non_nullable
              as List<TypeModel>,
      filterParams: filterParams == freezed
          ? _value.filterParams
          : filterParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      defaultOffset: defaultOffset == freezed
          ? _value.defaultOffset
          : defaultOffset // ignore: cast_nullable_to_non_nullable
              as int,
      defaultPageSize: defaultPageSize == freezed
          ? _value.defaultPageSize
          : defaultPageSize // ignore: cast_nullable_to_non_nullable
              as int,
      isInline: isInline == freezed
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$$_LoaderMethodModelCopyWith<$Res>
    implements $LoaderMethodModelCopyWith<$Res> {
  factory _$$_LoaderMethodModelCopyWith(_$_LoaderMethodModel value,
          $Res Function(_$_LoaderMethodModel) then) =
      __$$_LoaderMethodModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {String returnType,
      String name,
      bool hasFilter,
      bool isListLoader,
      bool isPaginated,
      bool hasRequiredParam,
      List<TypeModel> types,
      List<ParamModel> filterParams,
      int defaultOffset,
      int defaultPageSize,
      bool isInline});
}

/// @nodoc
class __$$_LoaderMethodModelCopyWithImpl<$Res>
    extends _$LoaderMethodModelCopyWithImpl<$Res>
    implements _$$_LoaderMethodModelCopyWith<$Res> {
  __$$_LoaderMethodModelCopyWithImpl(
      _$_LoaderMethodModel _value, $Res Function(_$_LoaderMethodModel) _then)
      : super(_value, (v) => _then(v as _$_LoaderMethodModel));

  @override
  _$_LoaderMethodModel get _value => super._value as _$_LoaderMethodModel;

  @override
  $Res call({
    Object? returnType = freezed,
    Object? name = freezed,
    Object? hasFilter = freezed,
    Object? isListLoader = freezed,
    Object? isPaginated = freezed,
    Object? hasRequiredParam = freezed,
    Object? types = freezed,
    Object? filterParams = freezed,
    Object? defaultOffset = freezed,
    Object? defaultPageSize = freezed,
    Object? isInline = freezed,
  }) {
    return _then(_$_LoaderMethodModel(
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: hasFilter == freezed
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      isListLoader: isListLoader == freezed
          ? _value.isListLoader
          : isListLoader // ignore: cast_nullable_to_non_nullable
              as bool,
      isPaginated: isPaginated == freezed
          ? _value.isPaginated
          : isPaginated // ignore: cast_nullable_to_non_nullable
              as bool,
      hasRequiredParam: hasRequiredParam == freezed
          ? _value.hasRequiredParam
          : hasRequiredParam // ignore: cast_nullable_to_non_nullable
              as bool,
      types: types == freezed
          ? _value._types
          : types // ignore: cast_nullable_to_non_nullable
              as List<TypeModel>,
      filterParams: filterParams == freezed
          ? _value._filterParams
          : filterParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      defaultOffset: defaultOffset == freezed
          ? _value.defaultOffset
          : defaultOffset // ignore: cast_nullable_to_non_nullable
              as int,
      defaultPageSize: defaultPageSize == freezed
          ? _value.defaultPageSize
          : defaultPageSize // ignore: cast_nullable_to_non_nullable
              as int,
      isInline: isInline == freezed
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$_LoaderMethodModel implements _LoaderMethodModel {
  const _$_LoaderMethodModel(
      {required this.returnType,
      required this.name,
      required this.hasFilter,
      required this.isListLoader,
      required this.isPaginated,
      required this.hasRequiredParam,
      required final List<TypeModel> types,
      required final List<ParamModel> filterParams,
      required this.defaultOffset,
      required this.defaultPageSize,
      this.isInline = false})
      : _types = types,
        _filterParams = filterParams;

  factory _$_LoaderMethodModel.fromJson(Map<String, dynamic> json) =>
      _$$_LoaderMethodModelFromJson(json);

  @override
  final String returnType;
  @override
  final String name;
  @override
  final bool hasFilter;
  @override
  final bool isListLoader;
  @override
  final bool isPaginated;
  @override
  final bool hasRequiredParam;
  final List<TypeModel> _types;
  @override
  List<TypeModel> get types {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_types);
  }

  final List<ParamModel> _filterParams;
  @override
  List<ParamModel> get filterParams {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filterParams);
  }

  @override
  final int defaultOffset;
  @override
  final int defaultPageSize;
  @override
  @JsonKey()
  final bool isInline;

  @override
  String toString() {
    return 'LoaderMethodModel(returnType: $returnType, name: $name, hasFilter: $hasFilter, isListLoader: $isListLoader, isPaginated: $isPaginated, hasRequiredParam: $hasRequiredParam, types: $types, filterParams: $filterParams, defaultOffset: $defaultOffset, defaultPageSize: $defaultPageSize, isInline: $isInline)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_LoaderMethodModel &&
            const DeepCollectionEquality()
                .equals(other.returnType, returnType) &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality().equals(other.hasFilter, hasFilter) &&
            const DeepCollectionEquality()
                .equals(other.isListLoader, isListLoader) &&
            const DeepCollectionEquality()
                .equals(other.isPaginated, isPaginated) &&
            const DeepCollectionEquality()
                .equals(other.hasRequiredParam, hasRequiredParam) &&
            const DeepCollectionEquality().equals(other._types, _types) &&
            const DeepCollectionEquality()
                .equals(other._filterParams, _filterParams) &&
            const DeepCollectionEquality()
                .equals(other.defaultOffset, defaultOffset) &&
            const DeepCollectionEquality()
                .equals(other.defaultPageSize, defaultPageSize) &&
            const DeepCollectionEquality().equals(other.isInline, isInline));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(returnType),
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(hasFilter),
      const DeepCollectionEquality().hash(isListLoader),
      const DeepCollectionEquality().hash(isPaginated),
      const DeepCollectionEquality().hash(hasRequiredParam),
      const DeepCollectionEquality().hash(_types),
      const DeepCollectionEquality().hash(_filterParams),
      const DeepCollectionEquality().hash(defaultOffset),
      const DeepCollectionEquality().hash(defaultPageSize),
      const DeepCollectionEquality().hash(isInline));

  @JsonKey(ignore: true)
  @override
  _$$_LoaderMethodModelCopyWith<_$_LoaderMethodModel> get copyWith =>
      __$$_LoaderMethodModelCopyWithImpl<_$_LoaderMethodModel>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_LoaderMethodModelToJson(this);
  }
}

abstract class _LoaderMethodModel implements LoaderMethodModel {
  const factory _LoaderMethodModel(
      {required final String returnType,
      required final String name,
      required final bool hasFilter,
      required final bool isListLoader,
      required final bool isPaginated,
      required final bool hasRequiredParam,
      required final List<TypeModel> types,
      required final List<ParamModel> filterParams,
      required final int defaultOffset,
      required final int defaultPageSize,
      final bool isInline}) = _$_LoaderMethodModel;

  factory _LoaderMethodModel.fromJson(Map<String, dynamic> json) =
      _$_LoaderMethodModel.fromJson;

  @override
  String get returnType => throw _privateConstructorUsedError;
  @override
  String get name => throw _privateConstructorUsedError;
  @override
  bool get hasFilter => throw _privateConstructorUsedError;
  @override
  bool get isListLoader => throw _privateConstructorUsedError;
  @override
  bool get isPaginated => throw _privateConstructorUsedError;
  @override
  bool get hasRequiredParam => throw _privateConstructorUsedError;
  @override
  List<TypeModel> get types => throw _privateConstructorUsedError;
  @override
  List<ParamModel> get filterParams => throw _privateConstructorUsedError;
  @override
  int get defaultOffset => throw _privateConstructorUsedError;
  @override
  int get defaultPageSize => throw _privateConstructorUsedError;
  @override
  bool get isInline => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_LoaderMethodModelCopyWith<_$_LoaderMethodModel> get copyWith =>
      throw _privateConstructorUsedError;
}

LoaderRepositoryTemplateModel _$LoaderRepositoryTemplateModelFromJson(
    Map<String, dynamic> json) {
  return _LoaderRepositoryTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$LoaderRepositoryTemplateModel {
  LoaderTemplateModel? get dataLoader => throw _privateConstructorUsedError;
  LoaderTemplateModel? get listLoader => throw _privateConstructorUsedError;
  bool get hasDataLoader => throw _privateConstructorUsedError;
  bool get hasListLoader => throw _privateConstructorUsedError;
  List<MethodModel> get crudMethods => throw _privateConstructorUsedError;
  String get repositoryName => throw _privateConstructorUsedError;
  String get api => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LoaderRepositoryTemplateModelCopyWith<LoaderRepositoryTemplateModel>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoaderRepositoryTemplateModelCopyWith<$Res> {
  factory $LoaderRepositoryTemplateModelCopyWith(
          LoaderRepositoryTemplateModel value,
          $Res Function(LoaderRepositoryTemplateModel) then) =
      _$LoaderRepositoryTemplateModelCopyWithImpl<$Res>;
  $Res call(
      {LoaderTemplateModel? dataLoader,
      LoaderTemplateModel? listLoader,
      bool hasDataLoader,
      bool hasListLoader,
      List<MethodModel> crudMethods,
      String repositoryName,
      String api});

  $LoaderTemplateModelCopyWith<$Res>? get dataLoader;
  $LoaderTemplateModelCopyWith<$Res>? get listLoader;
}

/// @nodoc
class _$LoaderRepositoryTemplateModelCopyWithImpl<$Res>
    implements $LoaderRepositoryTemplateModelCopyWith<$Res> {
  _$LoaderRepositoryTemplateModelCopyWithImpl(this._value, this._then);

  final LoaderRepositoryTemplateModel _value;
  // ignore: unused_field
  final $Res Function(LoaderRepositoryTemplateModel) _then;

  @override
  $Res call({
    Object? dataLoader = freezed,
    Object? listLoader = freezed,
    Object? hasDataLoader = freezed,
    Object? hasListLoader = freezed,
    Object? crudMethods = freezed,
    Object? repositoryName = freezed,
    Object? api = freezed,
  }) {
    return _then(_value.copyWith(
      dataLoader: dataLoader == freezed
          ? _value.dataLoader
          : dataLoader // ignore: cast_nullable_to_non_nullable
              as LoaderTemplateModel?,
      listLoader: listLoader == freezed
          ? _value.listLoader
          : listLoader // ignore: cast_nullable_to_non_nullable
              as LoaderTemplateModel?,
      hasDataLoader: hasDataLoader == freezed
          ? _value.hasDataLoader
          : hasDataLoader // ignore: cast_nullable_to_non_nullable
              as bool,
      hasListLoader: hasListLoader == freezed
          ? _value.hasListLoader
          : hasListLoader // ignore: cast_nullable_to_non_nullable
              as bool,
      crudMethods: crudMethods == freezed
          ? _value.crudMethods
          : crudMethods // ignore: cast_nullable_to_non_nullable
              as List<MethodModel>,
      repositoryName: repositoryName == freezed
          ? _value.repositoryName
          : repositoryName // ignore: cast_nullable_to_non_nullable
              as String,
      api: api == freezed
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }

  @override
  $LoaderTemplateModelCopyWith<$Res>? get dataLoader {
    if (_value.dataLoader == null) {
      return null;
    }

    return $LoaderTemplateModelCopyWith<$Res>(_value.dataLoader!, (value) {
      return _then(_value.copyWith(dataLoader: value));
    });
  }

  @override
  $LoaderTemplateModelCopyWith<$Res>? get listLoader {
    if (_value.listLoader == null) {
      return null;
    }

    return $LoaderTemplateModelCopyWith<$Res>(_value.listLoader!, (value) {
      return _then(_value.copyWith(listLoader: value));
    });
  }
}

/// @nodoc
abstract class _$$_LoaderRepositoryTemplateModelCopyWith<$Res>
    implements $LoaderRepositoryTemplateModelCopyWith<$Res> {
  factory _$$_LoaderRepositoryTemplateModelCopyWith(
          _$_LoaderRepositoryTemplateModel value,
          $Res Function(_$_LoaderRepositoryTemplateModel) then) =
      __$$_LoaderRepositoryTemplateModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {LoaderTemplateModel? dataLoader,
      LoaderTemplateModel? listLoader,
      bool hasDataLoader,
      bool hasListLoader,
      List<MethodModel> crudMethods,
      String repositoryName,
      String api});

  @override
  $LoaderTemplateModelCopyWith<$Res>? get dataLoader;
  @override
  $LoaderTemplateModelCopyWith<$Res>? get listLoader;
}

/// @nodoc
class __$$_LoaderRepositoryTemplateModelCopyWithImpl<$Res>
    extends _$LoaderRepositoryTemplateModelCopyWithImpl<$Res>
    implements _$$_LoaderRepositoryTemplateModelCopyWith<$Res> {
  __$$_LoaderRepositoryTemplateModelCopyWithImpl(
      _$_LoaderRepositoryTemplateModel _value,
      $Res Function(_$_LoaderRepositoryTemplateModel) _then)
      : super(_value, (v) => _then(v as _$_LoaderRepositoryTemplateModel));

  @override
  _$_LoaderRepositoryTemplateModel get _value =>
      super._value as _$_LoaderRepositoryTemplateModel;

  @override
  $Res call({
    Object? dataLoader = freezed,
    Object? listLoader = freezed,
    Object? hasDataLoader = freezed,
    Object? hasListLoader = freezed,
    Object? crudMethods = freezed,
    Object? repositoryName = freezed,
    Object? api = freezed,
  }) {
    return _then(_$_LoaderRepositoryTemplateModel(
      dataLoader: dataLoader == freezed
          ? _value.dataLoader
          : dataLoader // ignore: cast_nullable_to_non_nullable
              as LoaderTemplateModel?,
      listLoader: listLoader == freezed
          ? _value.listLoader
          : listLoader // ignore: cast_nullable_to_non_nullable
              as LoaderTemplateModel?,
      hasDataLoader: hasDataLoader == freezed
          ? _value.hasDataLoader
          : hasDataLoader // ignore: cast_nullable_to_non_nullable
              as bool,
      hasListLoader: hasListLoader == freezed
          ? _value.hasListLoader
          : hasListLoader // ignore: cast_nullable_to_non_nullable
              as bool,
      crudMethods: crudMethods == freezed
          ? _value._crudMethods
          : crudMethods // ignore: cast_nullable_to_non_nullable
              as List<MethodModel>,
      repositoryName: repositoryName == freezed
          ? _value.repositoryName
          : repositoryName // ignore: cast_nullable_to_non_nullable
              as String,
      api: api == freezed
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$_LoaderRepositoryTemplateModel
    implements _LoaderRepositoryTemplateModel {
  const _$_LoaderRepositoryTemplateModel(
      {this.dataLoader,
      this.listLoader,
      required this.hasDataLoader,
      required this.hasListLoader,
      required final List<MethodModel> crudMethods,
      required this.repositoryName,
      required this.api})
      : _crudMethods = crudMethods;

  factory _$_LoaderRepositoryTemplateModel.fromJson(
          Map<String, dynamic> json) =>
      _$$_LoaderRepositoryTemplateModelFromJson(json);

  @override
  final LoaderTemplateModel? dataLoader;
  @override
  final LoaderTemplateModel? listLoader;
  @override
  final bool hasDataLoader;
  @override
  final bool hasListLoader;
  final List<MethodModel> _crudMethods;
  @override
  List<MethodModel> get crudMethods {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_crudMethods);
  }

  @override
  final String repositoryName;
  @override
  final String api;

  @override
  String toString() {
    return 'LoaderRepositoryTemplateModel(dataLoader: $dataLoader, listLoader: $listLoader, hasDataLoader: $hasDataLoader, hasListLoader: $hasListLoader, crudMethods: $crudMethods, repositoryName: $repositoryName, api: $api)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_LoaderRepositoryTemplateModel &&
            const DeepCollectionEquality()
                .equals(other.dataLoader, dataLoader) &&
            const DeepCollectionEquality()
                .equals(other.listLoader, listLoader) &&
            const DeepCollectionEquality()
                .equals(other.hasDataLoader, hasDataLoader) &&
            const DeepCollectionEquality()
                .equals(other.hasListLoader, hasListLoader) &&
            const DeepCollectionEquality()
                .equals(other._crudMethods, _crudMethods) &&
            const DeepCollectionEquality()
                .equals(other.repositoryName, repositoryName) &&
            const DeepCollectionEquality().equals(other.api, api));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(dataLoader),
      const DeepCollectionEquality().hash(listLoader),
      const DeepCollectionEquality().hash(hasDataLoader),
      const DeepCollectionEquality().hash(hasListLoader),
      const DeepCollectionEquality().hash(_crudMethods),
      const DeepCollectionEquality().hash(repositoryName),
      const DeepCollectionEquality().hash(api));

  @JsonKey(ignore: true)
  @override
  _$$_LoaderRepositoryTemplateModelCopyWith<_$_LoaderRepositoryTemplateModel>
      get copyWith => __$$_LoaderRepositoryTemplateModelCopyWithImpl<
          _$_LoaderRepositoryTemplateModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_LoaderRepositoryTemplateModelToJson(this);
  }
}

abstract class _LoaderRepositoryTemplateModel
    implements LoaderRepositoryTemplateModel {
  const factory _LoaderRepositoryTemplateModel(
      {final LoaderTemplateModel? dataLoader,
      final LoaderTemplateModel? listLoader,
      required final bool hasDataLoader,
      required final bool hasListLoader,
      required final List<MethodModel> crudMethods,
      required final String repositoryName,
      required final String api}) = _$_LoaderRepositoryTemplateModel;

  factory _LoaderRepositoryTemplateModel.fromJson(Map<String, dynamic> json) =
      _$_LoaderRepositoryTemplateModel.fromJson;

  @override
  LoaderTemplateModel? get dataLoader => throw _privateConstructorUsedError;
  @override
  LoaderTemplateModel? get listLoader => throw _privateConstructorUsedError;
  @override
  bool get hasDataLoader => throw _privateConstructorUsedError;
  @override
  bool get hasListLoader => throw _privateConstructorUsedError;
  @override
  List<MethodModel> get crudMethods => throw _privateConstructorUsedError;
  @override
  String get repositoryName => throw _privateConstructorUsedError;
  @override
  String get api => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_LoaderRepositoryTemplateModelCopyWith<_$_LoaderRepositoryTemplateModel>
      get copyWith => throw _privateConstructorUsedError;
}

LoaderTemplateModel _$LoaderTemplateModelFromJson(Map<String, dynamic> json) {
  return _LoaderTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$LoaderTemplateModel {
  String get api => throw _privateConstructorUsedError;
  dynamic get hasRequiredParam => throw _privateConstructorUsedError;
  bool get isInline => throw _privateConstructorUsedError;
  String get methodName => throw _privateConstructorUsedError;
  String get returnType => throw _privateConstructorUsedError;
  bool get hasFilter => throw _privateConstructorUsedError;
  List<ParamModel> get additionalParams => throw _privateConstructorUsedError;
  List<ParamModel> get filterParams => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LoaderTemplateModelCopyWith<LoaderTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoaderTemplateModelCopyWith<$Res> {
  factory $LoaderTemplateModelCopyWith(
          LoaderTemplateModel value, $Res Function(LoaderTemplateModel) then) =
      _$LoaderTemplateModelCopyWithImpl<$Res>;
  $Res call(
      {String api,
      dynamic hasRequiredParam,
      bool isInline,
      String methodName,
      String returnType,
      bool hasFilter,
      List<ParamModel> additionalParams,
      List<ParamModel> filterParams});
}

/// @nodoc
class _$LoaderTemplateModelCopyWithImpl<$Res>
    implements $LoaderTemplateModelCopyWith<$Res> {
  _$LoaderTemplateModelCopyWithImpl(this._value, this._then);

  final LoaderTemplateModel _value;
  // ignore: unused_field
  final $Res Function(LoaderTemplateModel) _then;

  @override
  $Res call({
    Object? api = freezed,
    Object? hasRequiredParam = freezed,
    Object? isInline = freezed,
    Object? methodName = freezed,
    Object? returnType = freezed,
    Object? hasFilter = freezed,
    Object? additionalParams = freezed,
    Object? filterParams = freezed,
  }) {
    return _then(_value.copyWith(
      api: api == freezed
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
      hasRequiredParam: hasRequiredParam == freezed
          ? _value.hasRequiredParam
          : hasRequiredParam // ignore: cast_nullable_to_non_nullable
              as dynamic,
      isInline: isInline == freezed
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
      methodName: methodName == freezed
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: hasFilter == freezed
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      additionalParams: additionalParams == freezed
          ? _value.additionalParams
          : additionalParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      filterParams: filterParams == freezed
          ? _value.filterParams
          : filterParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
    ));
  }
}

/// @nodoc
abstract class _$$_LoaderTemplateModelCopyWith<$Res>
    implements $LoaderTemplateModelCopyWith<$Res> {
  factory _$$_LoaderTemplateModelCopyWith(_$_LoaderTemplateModel value,
          $Res Function(_$_LoaderTemplateModel) then) =
      __$$_LoaderTemplateModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {String api,
      dynamic hasRequiredParam,
      bool isInline,
      String methodName,
      String returnType,
      bool hasFilter,
      List<ParamModel> additionalParams,
      List<ParamModel> filterParams});
}

/// @nodoc
class __$$_LoaderTemplateModelCopyWithImpl<$Res>
    extends _$LoaderTemplateModelCopyWithImpl<$Res>
    implements _$$_LoaderTemplateModelCopyWith<$Res> {
  __$$_LoaderTemplateModelCopyWithImpl(_$_LoaderTemplateModel _value,
      $Res Function(_$_LoaderTemplateModel) _then)
      : super(_value, (v) => _then(v as _$_LoaderTemplateModel));

  @override
  _$_LoaderTemplateModel get _value => super._value as _$_LoaderTemplateModel;

  @override
  $Res call({
    Object? api = freezed,
    Object? hasRequiredParam = freezed,
    Object? isInline = freezed,
    Object? methodName = freezed,
    Object? returnType = freezed,
    Object? hasFilter = freezed,
    Object? additionalParams = freezed,
    Object? filterParams = freezed,
  }) {
    return _then(_$_LoaderTemplateModel(
      api: api == freezed
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
      hasRequiredParam: hasRequiredParam == freezed
          ? _value.hasRequiredParam
          : hasRequiredParam,
      isInline: isInline == freezed
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
      methodName: methodName == freezed
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: hasFilter == freezed
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      additionalParams: additionalParams == freezed
          ? _value._additionalParams
          : additionalParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      filterParams: filterParams == freezed
          ? _value._filterParams
          : filterParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$_LoaderTemplateModel implements _LoaderTemplateModel {
  const _$_LoaderTemplateModel(
      {required this.api,
      this.hasRequiredParam = false,
      this.isInline = false,
      required this.methodName,
      required this.returnType,
      this.hasFilter = false,
      final List<ParamModel> additionalParams = const [],
      final List<ParamModel> filterParams = const []})
      : _additionalParams = additionalParams,
        _filterParams = filterParams;

  factory _$_LoaderTemplateModel.fromJson(Map<String, dynamic> json) =>
      _$$_LoaderTemplateModelFromJson(json);

  @override
  final String api;
  @override
  @JsonKey()
  final dynamic hasRequiredParam;
  @override
  @JsonKey()
  final bool isInline;
  @override
  final String methodName;
  @override
  final String returnType;
  @override
  @JsonKey()
  final bool hasFilter;
  final List<ParamModel> _additionalParams;
  @override
  @JsonKey()
  List<ParamModel> get additionalParams {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_additionalParams);
  }

  final List<ParamModel> _filterParams;
  @override
  @JsonKey()
  List<ParamModel> get filterParams {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filterParams);
  }

  @override
  String toString() {
    return 'LoaderTemplateModel(api: $api, hasRequiredParam: $hasRequiredParam, isInline: $isInline, methodName: $methodName, returnType: $returnType, hasFilter: $hasFilter, additionalParams: $additionalParams, filterParams: $filterParams)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_LoaderTemplateModel &&
            const DeepCollectionEquality().equals(other.api, api) &&
            const DeepCollectionEquality()
                .equals(other.hasRequiredParam, hasRequiredParam) &&
            const DeepCollectionEquality().equals(other.isInline, isInline) &&
            const DeepCollectionEquality()
                .equals(other.methodName, methodName) &&
            const DeepCollectionEquality()
                .equals(other.returnType, returnType) &&
            const DeepCollectionEquality().equals(other.hasFilter, hasFilter) &&
            const DeepCollectionEquality()
                .equals(other._additionalParams, _additionalParams) &&
            const DeepCollectionEquality()
                .equals(other._filterParams, _filterParams));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(api),
      const DeepCollectionEquality().hash(hasRequiredParam),
      const DeepCollectionEquality().hash(isInline),
      const DeepCollectionEquality().hash(methodName),
      const DeepCollectionEquality().hash(returnType),
      const DeepCollectionEquality().hash(hasFilter),
      const DeepCollectionEquality().hash(_additionalParams),
      const DeepCollectionEquality().hash(_filterParams));

  @JsonKey(ignore: true)
  @override
  _$$_LoaderTemplateModelCopyWith<_$_LoaderTemplateModel> get copyWith =>
      __$$_LoaderTemplateModelCopyWithImpl<_$_LoaderTemplateModel>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_LoaderTemplateModelToJson(this);
  }
}

abstract class _LoaderTemplateModel implements LoaderTemplateModel {
  const factory _LoaderTemplateModel(
      {required final String api,
      final dynamic hasRequiredParam,
      final bool isInline,
      required final String methodName,
      required final String returnType,
      final bool hasFilter,
      final List<ParamModel> additionalParams,
      final List<ParamModel> filterParams}) = _$_LoaderTemplateModel;

  factory _LoaderTemplateModel.fromJson(Map<String, dynamic> json) =
      _$_LoaderTemplateModel.fromJson;

  @override
  String get api => throw _privateConstructorUsedError;
  @override
  dynamic get hasRequiredParam => throw _privateConstructorUsedError;
  @override
  bool get isInline => throw _privateConstructorUsedError;
  @override
  String get methodName => throw _privateConstructorUsedError;
  @override
  String get returnType => throw _privateConstructorUsedError;
  @override
  bool get hasFilter => throw _privateConstructorUsedError;
  @override
  List<ParamModel> get additionalParams => throw _privateConstructorUsedError;
  @override
  List<ParamModel> get filterParams => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_LoaderTemplateModelCopyWith<_$_LoaderTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

CubitTemplateModel _$CubitTemplateModelFromJson(Map<String, dynamic> json) {
  return _CubitTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$CubitTemplateModel {
  String get name => throw _privateConstructorUsedError;
  String get returnType => throw _privateConstructorUsedError;
  bool get hasFilter => throw _privateConstructorUsedError;
  List<MethodModel> get crudMethods => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $CubitTemplateModelCopyWith<CubitTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CubitTemplateModelCopyWith<$Res> {
  factory $CubitTemplateModelCopyWith(
          CubitTemplateModel value, $Res Function(CubitTemplateModel) then) =
      _$CubitTemplateModelCopyWithImpl<$Res>;
  $Res call(
      {String name,
      String returnType,
      bool hasFilter,
      List<MethodModel> crudMethods});
}

/// @nodoc
class _$CubitTemplateModelCopyWithImpl<$Res>
    implements $CubitTemplateModelCopyWith<$Res> {
  _$CubitTemplateModelCopyWithImpl(this._value, this._then);

  final CubitTemplateModel _value;
  // ignore: unused_field
  final $Res Function(CubitTemplateModel) _then;

  @override
  $Res call({
    Object? name = freezed,
    Object? returnType = freezed,
    Object? hasFilter = freezed,
    Object? crudMethods = freezed,
  }) {
    return _then(_value.copyWith(
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: hasFilter == freezed
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      crudMethods: crudMethods == freezed
          ? _value.crudMethods
          : crudMethods // ignore: cast_nullable_to_non_nullable
              as List<MethodModel>,
    ));
  }
}

/// @nodoc
abstract class _$$_CubitTemplateModelCopyWith<$Res>
    implements $CubitTemplateModelCopyWith<$Res> {
  factory _$$_CubitTemplateModelCopyWith(_$_CubitTemplateModel value,
          $Res Function(_$_CubitTemplateModel) then) =
      __$$_CubitTemplateModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {String name,
      String returnType,
      bool hasFilter,
      List<MethodModel> crudMethods});
}

/// @nodoc
class __$$_CubitTemplateModelCopyWithImpl<$Res>
    extends _$CubitTemplateModelCopyWithImpl<$Res>
    implements _$$_CubitTemplateModelCopyWith<$Res> {
  __$$_CubitTemplateModelCopyWithImpl(
      _$_CubitTemplateModel _value, $Res Function(_$_CubitTemplateModel) _then)
      : super(_value, (v) => _then(v as _$_CubitTemplateModel));

  @override
  _$_CubitTemplateModel get _value => super._value as _$_CubitTemplateModel;

  @override
  $Res call({
    Object? name = freezed,
    Object? returnType = freezed,
    Object? hasFilter = freezed,
    Object? crudMethods = freezed,
  }) {
    return _then(_$_CubitTemplateModel(
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: hasFilter == freezed
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      crudMethods: crudMethods == freezed
          ? _value._crudMethods
          : crudMethods // ignore: cast_nullable_to_non_nullable
              as List<MethodModel>,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$_CubitTemplateModel implements _CubitTemplateModel {
  const _$_CubitTemplateModel(
      {required this.name,
      required this.returnType,
      this.hasFilter = false,
      required final List<MethodModel> crudMethods})
      : _crudMethods = crudMethods;

  factory _$_CubitTemplateModel.fromJson(Map<String, dynamic> json) =>
      _$$_CubitTemplateModelFromJson(json);

  @override
  final String name;
  @override
  final String returnType;
  @override
  @JsonKey()
  final bool hasFilter;
  final List<MethodModel> _crudMethods;
  @override
  List<MethodModel> get crudMethods {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_crudMethods);
  }

  @override
  String toString() {
    return 'CubitTemplateModel(name: $name, returnType: $returnType, hasFilter: $hasFilter, crudMethods: $crudMethods)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CubitTemplateModel &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality()
                .equals(other.returnType, returnType) &&
            const DeepCollectionEquality().equals(other.hasFilter, hasFilter) &&
            const DeepCollectionEquality()
                .equals(other._crudMethods, _crudMethods));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(returnType),
      const DeepCollectionEquality().hash(hasFilter),
      const DeepCollectionEquality().hash(_crudMethods));

  @JsonKey(ignore: true)
  @override
  _$$_CubitTemplateModelCopyWith<_$_CubitTemplateModel> get copyWith =>
      __$$_CubitTemplateModelCopyWithImpl<_$_CubitTemplateModel>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_CubitTemplateModelToJson(this);
  }
}

abstract class _CubitTemplateModel implements CubitTemplateModel {
  const factory _CubitTemplateModel(
      {required final String name,
      required final String returnType,
      final bool hasFilter,
      required final List<MethodModel> crudMethods}) = _$_CubitTemplateModel;

  factory _CubitTemplateModel.fromJson(Map<String, dynamic> json) =
      _$_CubitTemplateModel.fromJson;

  @override
  String get name => throw _privateConstructorUsedError;
  @override
  String get returnType => throw _privateConstructorUsedError;
  @override
  bool get hasFilter => throw _privateConstructorUsedError;
  @override
  List<MethodModel> get crudMethods => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_CubitTemplateModelCopyWith<_$_CubitTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

BuiltListJsonConverterTemplateModel
    _$BuiltListJsonConverterTemplateModelFromJson(Map<String, dynamic> json) {
  return _BuiltListJsonConverterTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$BuiltListJsonConverterTemplateModel {
  String get converterName => throw _privateConstructorUsedError;
  String get innerReturnType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BuiltListJsonConverterTemplateModelCopyWith<
          BuiltListJsonConverterTemplateModel>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BuiltListJsonConverterTemplateModelCopyWith<$Res> {
  factory $BuiltListJsonConverterTemplateModelCopyWith(
          BuiltListJsonConverterTemplateModel value,
          $Res Function(BuiltListJsonConverterTemplateModel) then) =
      _$BuiltListJsonConverterTemplateModelCopyWithImpl<$Res>;
  $Res call({String converterName, String innerReturnType});
}

/// @nodoc
class _$BuiltListJsonConverterTemplateModelCopyWithImpl<$Res>
    implements $BuiltListJsonConverterTemplateModelCopyWith<$Res> {
  _$BuiltListJsonConverterTemplateModelCopyWithImpl(this._value, this._then);

  final BuiltListJsonConverterTemplateModel _value;
  // ignore: unused_field
  final $Res Function(BuiltListJsonConverterTemplateModel) _then;

  @override
  $Res call({
    Object? converterName = freezed,
    Object? innerReturnType = freezed,
  }) {
    return _then(_value.copyWith(
      converterName: converterName == freezed
          ? _value.converterName
          : converterName // ignore: cast_nullable_to_non_nullable
              as String,
      innerReturnType: innerReturnType == freezed
          ? _value.innerReturnType
          : innerReturnType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_BuiltListJsonConverterTemplateModelCopyWith<$Res>
    implements $BuiltListJsonConverterTemplateModelCopyWith<$Res> {
  factory _$$_BuiltListJsonConverterTemplateModelCopyWith(
          _$_BuiltListJsonConverterTemplateModel value,
          $Res Function(_$_BuiltListJsonConverterTemplateModel) then) =
      __$$_BuiltListJsonConverterTemplateModelCopyWithImpl<$Res>;
  @override
  $Res call({String converterName, String innerReturnType});
}

/// @nodoc
class __$$_BuiltListJsonConverterTemplateModelCopyWithImpl<$Res>
    extends _$BuiltListJsonConverterTemplateModelCopyWithImpl<$Res>
    implements _$$_BuiltListJsonConverterTemplateModelCopyWith<$Res> {
  __$$_BuiltListJsonConverterTemplateModelCopyWithImpl(
      _$_BuiltListJsonConverterTemplateModel _value,
      $Res Function(_$_BuiltListJsonConverterTemplateModel) _then)
      : super(
            _value, (v) => _then(v as _$_BuiltListJsonConverterTemplateModel));

  @override
  _$_BuiltListJsonConverterTemplateModel get _value =>
      super._value as _$_BuiltListJsonConverterTemplateModel;

  @override
  $Res call({
    Object? converterName = freezed,
    Object? innerReturnType = freezed,
  }) {
    return _then(_$_BuiltListJsonConverterTemplateModel(
      converterName: converterName == freezed
          ? _value.converterName
          : converterName // ignore: cast_nullable_to_non_nullable
              as String,
      innerReturnType: innerReturnType == freezed
          ? _value.innerReturnType
          : innerReturnType // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_BuiltListJsonConverterTemplateModel
    implements _BuiltListJsonConverterTemplateModel {
  const _$_BuiltListJsonConverterTemplateModel(
      {required this.converterName, required this.innerReturnType});

  factory _$_BuiltListJsonConverterTemplateModel.fromJson(
          Map<String, dynamic> json) =>
      _$$_BuiltListJsonConverterTemplateModelFromJson(json);

  @override
  final String converterName;
  @override
  final String innerReturnType;

  @override
  String toString() {
    return 'BuiltListJsonConverterTemplateModel(converterName: $converterName, innerReturnType: $innerReturnType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BuiltListJsonConverterTemplateModel &&
            const DeepCollectionEquality()
                .equals(other.converterName, converterName) &&
            const DeepCollectionEquality()
                .equals(other.innerReturnType, innerReturnType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(converterName),
      const DeepCollectionEquality().hash(innerReturnType));

  @JsonKey(ignore: true)
  @override
  _$$_BuiltListJsonConverterTemplateModelCopyWith<
          _$_BuiltListJsonConverterTemplateModel>
      get copyWith => __$$_BuiltListJsonConverterTemplateModelCopyWithImpl<
          _$_BuiltListJsonConverterTemplateModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_BuiltListJsonConverterTemplateModelToJson(this);
  }
}

abstract class _BuiltListJsonConverterTemplateModel
    implements BuiltListJsonConverterTemplateModel {
  const factory _BuiltListJsonConverterTemplateModel(
          {required final String converterName,
          required final String innerReturnType}) =
      _$_BuiltListJsonConverterTemplateModel;

  factory _BuiltListJsonConverterTemplateModel.fromJson(
          Map<String, dynamic> json) =
      _$_BuiltListJsonConverterTemplateModel.fromJson;

  @override
  String get converterName => throw _privateConstructorUsedError;
  @override
  String get innerReturnType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_BuiltListJsonConverterTemplateModelCopyWith<
          _$_BuiltListJsonConverterTemplateModel>
      get copyWith => throw _privateConstructorUsedError;
}
