// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'models.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

RepositoryTemplateModel _$RepositoryTemplateModelFromJson(
    Map<String, dynamic> json) {
  return _RepositoryTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$RepositoryTemplateModel {
  String get repositoryName => throw _privateConstructorUsedError;
  String get baseUrl => throw _privateConstructorUsedError;
  String get liveBasePath => throw _privateConstructorUsedError;
  List<AccessorModel> get accessors => throw _privateConstructorUsedError;
  int get connectTimeout => throw _privateConstructorUsedError;
  int get receiveTimeout => throw _privateConstructorUsedError;
  int get sendTimeout => throw _privateConstructorUsedError;
  String? get dioInterceptor => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $RepositoryTemplateModelCopyWith<RepositoryTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RepositoryTemplateModelCopyWith<$Res> {
  factory $RepositoryTemplateModelCopyWith(RepositoryTemplateModel value,
          $Res Function(RepositoryTemplateModel) then) =
      _$RepositoryTemplateModelCopyWithImpl<$Res>;
  $Res call(
      {String repositoryName,
      String baseUrl,
      String liveBasePath,
      List<AccessorModel> accessors,
      int connectTimeout,
      int receiveTimeout,
      int sendTimeout,
      String? dioInterceptor});
}

/// @nodoc
class _$RepositoryTemplateModelCopyWithImpl<$Res>
    implements $RepositoryTemplateModelCopyWith<$Res> {
  _$RepositoryTemplateModelCopyWithImpl(this._value, this._then);

  final RepositoryTemplateModel _value;
  // ignore: unused_field
  final $Res Function(RepositoryTemplateModel) _then;

  @override
  $Res call({
    Object? repositoryName = freezed,
    Object? baseUrl = freezed,
    Object? liveBasePath = freezed,
    Object? accessors = freezed,
    Object? connectTimeout = freezed,
    Object? receiveTimeout = freezed,
    Object? sendTimeout = freezed,
    Object? dioInterceptor = freezed,
  }) {
    return _then(_value.copyWith(
      repositoryName: repositoryName == freezed
          ? _value.repositoryName
          : repositoryName // ignore: cast_nullable_to_non_nullable
              as String,
      baseUrl: baseUrl == freezed
          ? _value.baseUrl
          : baseUrl // ignore: cast_nullable_to_non_nullable
              as String,
      liveBasePath: liveBasePath == freezed
          ? _value.liveBasePath
          : liveBasePath // ignore: cast_nullable_to_non_nullable
              as String,
      accessors: accessors == freezed
          ? _value.accessors
          : accessors // ignore: cast_nullable_to_non_nullable
              as List<AccessorModel>,
      connectTimeout: connectTimeout == freezed
          ? _value.connectTimeout
          : connectTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      receiveTimeout: receiveTimeout == freezed
          ? _value.receiveTimeout
          : receiveTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      sendTimeout: sendTimeout == freezed
          ? _value.sendTimeout
          : sendTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      dioInterceptor: dioInterceptor == freezed
          ? _value.dioInterceptor
          : dioInterceptor // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$$_RepositoryTemplateModelCopyWith<$Res>
    implements $RepositoryTemplateModelCopyWith<$Res> {
  factory _$$_RepositoryTemplateModelCopyWith(_$_RepositoryTemplateModel value,
          $Res Function(_$_RepositoryTemplateModel) then) =
      __$$_RepositoryTemplateModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {String repositoryName,
      String baseUrl,
      String liveBasePath,
      List<AccessorModel> accessors,
      int connectTimeout,
      int receiveTimeout,
      int sendTimeout,
      String? dioInterceptor});
}

/// @nodoc
class __$$_RepositoryTemplateModelCopyWithImpl<$Res>
    extends _$RepositoryTemplateModelCopyWithImpl<$Res>
    implements _$$_RepositoryTemplateModelCopyWith<$Res> {
  __$$_RepositoryTemplateModelCopyWithImpl(_$_RepositoryTemplateModel _value,
      $Res Function(_$_RepositoryTemplateModel) _then)
      : super(_value, (v) => _then(v as _$_RepositoryTemplateModel));

  @override
  _$_RepositoryTemplateModel get _value =>
      super._value as _$_RepositoryTemplateModel;

  @override
  $Res call({
    Object? repositoryName = freezed,
    Object? baseUrl = freezed,
    Object? liveBasePath = freezed,
    Object? accessors = freezed,
    Object? connectTimeout = freezed,
    Object? receiveTimeout = freezed,
    Object? sendTimeout = freezed,
    Object? dioInterceptor = freezed,
  }) {
    return _then(_$_RepositoryTemplateModel(
      repositoryName: repositoryName == freezed
          ? _value.repositoryName
          : repositoryName // ignore: cast_nullable_to_non_nullable
              as String,
      baseUrl: baseUrl == freezed
          ? _value.baseUrl
          : baseUrl // ignore: cast_nullable_to_non_nullable
              as String,
      liveBasePath: liveBasePath == freezed
          ? _value.liveBasePath
          : liveBasePath // ignore: cast_nullable_to_non_nullable
              as String,
      accessors: accessors == freezed
          ? _value._accessors
          : accessors // ignore: cast_nullable_to_non_nullable
              as List<AccessorModel>,
      connectTimeout: connectTimeout == freezed
          ? _value.connectTimeout
          : connectTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      receiveTimeout: receiveTimeout == freezed
          ? _value.receiveTimeout
          : receiveTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      sendTimeout: sendTimeout == freezed
          ? _value.sendTimeout
          : sendTimeout // ignore: cast_nullable_to_non_nullable
              as int,
      dioInterceptor: dioInterceptor == freezed
          ? _value.dioInterceptor
          : dioInterceptor // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$_RepositoryTemplateModel implements _RepositoryTemplateModel {
  const _$_RepositoryTemplateModel(
      {required this.repositoryName,
      required this.baseUrl,
      required this.liveBasePath,
      final List<AccessorModel> accessors = const [],
      required this.connectTimeout,
      required this.receiveTimeout,
      required this.sendTimeout,
      this.dioInterceptor})
      : _accessors = accessors;

  factory _$_RepositoryTemplateModel.fromJson(Map<String, dynamic> json) =>
      _$$_RepositoryTemplateModelFromJson(json);

  @override
  final String repositoryName;
  @override
  final String baseUrl;
  @override
  final String liveBasePath;
  final List<AccessorModel> _accessors;
  @override
  @JsonKey()
  List<AccessorModel> get accessors {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_accessors);
  }

  @override
  final int connectTimeout;
  @override
  final int receiveTimeout;
  @override
  final int sendTimeout;
  @override
  final String? dioInterceptor;

  @override
  String toString() {
    return 'RepositoryTemplateModel(repositoryName: $repositoryName, baseUrl: $baseUrl, liveBasePath: $liveBasePath, accessors: $accessors, connectTimeout: $connectTimeout, receiveTimeout: $receiveTimeout, sendTimeout: $sendTimeout, dioInterceptor: $dioInterceptor)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RepositoryTemplateModel &&
            const DeepCollectionEquality()
                .equals(other.repositoryName, repositoryName) &&
            const DeepCollectionEquality().equals(other.baseUrl, baseUrl) &&
            const DeepCollectionEquality()
                .equals(other.liveBasePath, liveBasePath) &&
            const DeepCollectionEquality()
                .equals(other._accessors, _accessors) &&
            const DeepCollectionEquality()
                .equals(other.connectTimeout, connectTimeout) &&
            const DeepCollectionEquality()
                .equals(other.receiveTimeout, receiveTimeout) &&
            const DeepCollectionEquality()
                .equals(other.sendTimeout, sendTimeout) &&
            const DeepCollectionEquality()
                .equals(other.dioInterceptor, dioInterceptor));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(repositoryName),
      const DeepCollectionEquality().hash(baseUrl),
      const DeepCollectionEquality().hash(liveBasePath),
      const DeepCollectionEquality().hash(_accessors),
      const DeepCollectionEquality().hash(connectTimeout),
      const DeepCollectionEquality().hash(receiveTimeout),
      const DeepCollectionEquality().hash(sendTimeout),
      const DeepCollectionEquality().hash(dioInterceptor));

  @JsonKey(ignore: true)
  @override
  _$$_RepositoryTemplateModelCopyWith<_$_RepositoryTemplateModel>
      get copyWith =>
          __$$_RepositoryTemplateModelCopyWithImpl<_$_RepositoryTemplateModel>(
              this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_RepositoryTemplateModelToJson(this);
  }
}

abstract class _RepositoryTemplateModel implements RepositoryTemplateModel {
  const factory _RepositoryTemplateModel(
      {required final String repositoryName,
      required final String baseUrl,
      required final String liveBasePath,
      final List<AccessorModel> accessors,
      required final int connectTimeout,
      required final int receiveTimeout,
      required final int sendTimeout,
      final String? dioInterceptor}) = _$_RepositoryTemplateModel;

  factory _RepositoryTemplateModel.fromJson(Map<String, dynamic> json) =
      _$_RepositoryTemplateModel.fromJson;

  @override
  String get repositoryName => throw _privateConstructorUsedError;
  @override
  String get baseUrl => throw _privateConstructorUsedError;
  @override
  String get liveBasePath => throw _privateConstructorUsedError;
  @override
  List<AccessorModel> get accessors => throw _privateConstructorUsedError;
  @override
  int get connectTimeout => throw _privateConstructorUsedError;
  @override
  int get receiveTimeout => throw _privateConstructorUsedError;
  @override
  int get sendTimeout => throw _privateConstructorUsedError;
  @override
  String? get dioInterceptor => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_RepositoryTemplateModelCopyWith<_$_RepositoryTemplateModel>
      get copyWith => throw _privateConstructorUsedError;
}

AccessorModel _$AccessorModelFromJson(Map<String, dynamic> json) {
  return _AccessorModel.fromJson(json);
}

/// @nodoc
mixin _$AccessorModel {
  String get type => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get methodName => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AccessorModelCopyWith<AccessorModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccessorModelCopyWith<$Res> {
  factory $AccessorModelCopyWith(
          AccessorModel value, $Res Function(AccessorModel) then) =
      _$AccessorModelCopyWithImpl<$Res>;
  $Res call({String type, String name, String methodName});
}

/// @nodoc
class _$AccessorModelCopyWithImpl<$Res>
    implements $AccessorModelCopyWith<$Res> {
  _$AccessorModelCopyWithImpl(this._value, this._then);

  final AccessorModel _value;
  // ignore: unused_field
  final $Res Function(AccessorModel) _then;

  @override
  $Res call({
    Object? type = freezed,
    Object? name = freezed,
    Object? methodName = freezed,
  }) {
    return _then(_value.copyWith(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      methodName: methodName == freezed
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_AccessorModelCopyWith<$Res>
    implements $AccessorModelCopyWith<$Res> {
  factory _$$_AccessorModelCopyWith(
          _$_AccessorModel value, $Res Function(_$_AccessorModel) then) =
      __$$_AccessorModelCopyWithImpl<$Res>;
  @override
  $Res call({String type, String name, String methodName});
}

/// @nodoc
class __$$_AccessorModelCopyWithImpl<$Res>
    extends _$AccessorModelCopyWithImpl<$Res>
    implements _$$_AccessorModelCopyWith<$Res> {
  __$$_AccessorModelCopyWithImpl(
      _$_AccessorModel _value, $Res Function(_$_AccessorModel) _then)
      : super(_value, (v) => _then(v as _$_AccessorModel));

  @override
  _$_AccessorModel get _value => super._value as _$_AccessorModel;

  @override
  $Res call({
    Object? type = freezed,
    Object? name = freezed,
    Object? methodName = freezed,
  }) {
    return _then(_$_AccessorModel(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      methodName: methodName == freezed
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_AccessorModel implements _AccessorModel {
  const _$_AccessorModel(
      {required this.type, required this.name, required this.methodName});

  factory _$_AccessorModel.fromJson(Map<String, dynamic> json) =>
      _$$_AccessorModelFromJson(json);

  @override
  final String type;
  @override
  final String name;
  @override
  final String methodName;

  @override
  String toString() {
    return 'AccessorModel(type: $type, name: $name, methodName: $methodName)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AccessorModel &&
            const DeepCollectionEquality().equals(other.type, type) &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality()
                .equals(other.methodName, methodName));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(type),
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(methodName));

  @JsonKey(ignore: true)
  @override
  _$$_AccessorModelCopyWith<_$_AccessorModel> get copyWith =>
      __$$_AccessorModelCopyWithImpl<_$_AccessorModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_AccessorModelToJson(this);
  }
}

abstract class _AccessorModel implements AccessorModel {
  const factory _AccessorModel(
      {required final String type,
      required final String name,
      required final String methodName}) = _$_AccessorModel;

  factory _AccessorModel.fromJson(Map<String, dynamic> json) =
      _$_AccessorModel.fromJson;

  @override
  String get type => throw _privateConstructorUsedError;
  @override
  String get name => throw _privateConstructorUsedError;
  @override
  String get methodName => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_AccessorModelCopyWith<_$_AccessorModel> get copyWith =>
      throw _privateConstructorUsedError;
}

FreezedTemplateModel _$FreezedTemplateModelFromJson(Map<String, dynamic> json) {
  return _FreezedTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$FreezedTemplateModel {
  String get name => throw _privateConstructorUsedError;
  bool get isPaginated => throw _privateConstructorUsedError;
  List<TypeModel> get types => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $FreezedTemplateModelCopyWith<FreezedTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FreezedTemplateModelCopyWith<$Res> {
  factory $FreezedTemplateModelCopyWith(FreezedTemplateModel value,
          $Res Function(FreezedTemplateModel) then) =
      _$FreezedTemplateModelCopyWithImpl<$Res>;
  $Res call({String name, bool isPaginated, List<TypeModel> types});
}

/// @nodoc
class _$FreezedTemplateModelCopyWithImpl<$Res>
    implements $FreezedTemplateModelCopyWith<$Res> {
  _$FreezedTemplateModelCopyWithImpl(this._value, this._then);

  final FreezedTemplateModel _value;
  // ignore: unused_field
  final $Res Function(FreezedTemplateModel) _then;

  @override
  $Res call({
    Object? name = freezed,
    Object? isPaginated = freezed,
    Object? types = freezed,
  }) {
    return _then(_value.copyWith(
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      isPaginated: isPaginated == freezed
          ? _value.isPaginated
          : isPaginated // ignore: cast_nullable_to_non_nullable
              as bool,
      types: types == freezed
          ? _value.types
          : types // ignore: cast_nullable_to_non_nullable
              as List<TypeModel>,
    ));
  }
}

/// @nodoc
abstract class _$$_FreezedTemplateModelCopyWith<$Res>
    implements $FreezedTemplateModelCopyWith<$Res> {
  factory _$$_FreezedTemplateModelCopyWith(_$_FreezedTemplateModel value,
          $Res Function(_$_FreezedTemplateModel) then) =
      __$$_FreezedTemplateModelCopyWithImpl<$Res>;
  @override
  $Res call({String name, bool isPaginated, List<TypeModel> types});
}

/// @nodoc
class __$$_FreezedTemplateModelCopyWithImpl<$Res>
    extends _$FreezedTemplateModelCopyWithImpl<$Res>
    implements _$$_FreezedTemplateModelCopyWith<$Res> {
  __$$_FreezedTemplateModelCopyWithImpl(_$_FreezedTemplateModel _value,
      $Res Function(_$_FreezedTemplateModel) _then)
      : super(_value, (v) => _then(v as _$_FreezedTemplateModel));

  @override
  _$_FreezedTemplateModel get _value => super._value as _$_FreezedTemplateModel;

  @override
  $Res call({
    Object? name = freezed,
    Object? isPaginated = freezed,
    Object? types = freezed,
  }) {
    return _then(_$_FreezedTemplateModel(
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      isPaginated: isPaginated == freezed
          ? _value.isPaginated
          : isPaginated // ignore: cast_nullable_to_non_nullable
              as bool,
      types: types == freezed
          ? _value._types
          : types // ignore: cast_nullable_to_non_nullable
              as List<TypeModel>,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$_FreezedTemplateModel implements _FreezedTemplateModel {
  const _$_FreezedTemplateModel(
      {required this.name,
      this.isPaginated = true,
      final List<TypeModel> types = const []})
      : _types = types;

  factory _$_FreezedTemplateModel.fromJson(Map<String, dynamic> json) =>
      _$$_FreezedTemplateModelFromJson(json);

  @override
  final String name;
  @override
  @JsonKey()
  final bool isPaginated;
  final List<TypeModel> _types;
  @override
  @JsonKey()
  List<TypeModel> get types {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_types);
  }

  @override
  String toString() {
    return 'FreezedTemplateModel(name: $name, isPaginated: $isPaginated, types: $types)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_FreezedTemplateModel &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality()
                .equals(other.isPaginated, isPaginated) &&
            const DeepCollectionEquality().equals(other._types, _types));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(isPaginated),
      const DeepCollectionEquality().hash(_types));

  @JsonKey(ignore: true)
  @override
  _$$_FreezedTemplateModelCopyWith<_$_FreezedTemplateModel> get copyWith =>
      __$$_FreezedTemplateModelCopyWithImpl<_$_FreezedTemplateModel>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_FreezedTemplateModelToJson(this);
  }
}

abstract class _FreezedTemplateModel implements FreezedTemplateModel {
  const factory _FreezedTemplateModel(
      {required final String name,
      final bool isPaginated,
      final List<TypeModel> types}) = _$_FreezedTemplateModel;

  factory _FreezedTemplateModel.fromJson(Map<String, dynamic> json) =
      _$_FreezedTemplateModel.fromJson;

  @override
  String get name => throw _privateConstructorUsedError;
  @override
  bool get isPaginated => throw _privateConstructorUsedError;
  @override
  List<TypeModel> get types => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_FreezedTemplateModelCopyWith<_$_FreezedTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

TypeModel _$TypeModelFromJson(Map<String, dynamic> json) {
  return _TypeModel.fromJson(json);
}

/// @nodoc
mixin _$TypeModel {
  bool get isRequired => throw _privateConstructorUsedError;
  bool get isNullable => throw _privateConstructorUsedError;
  String? get defaultValue => throw _privateConstructorUsedError;
  String get type => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TypeModelCopyWith<TypeModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TypeModelCopyWith<$Res> {
  factory $TypeModelCopyWith(TypeModel value, $Res Function(TypeModel) then) =
      _$TypeModelCopyWithImpl<$Res>;
  $Res call(
      {bool isRequired,
      bool isNullable,
      String? defaultValue,
      String type,
      String name});
}

/// @nodoc
class _$TypeModelCopyWithImpl<$Res> implements $TypeModelCopyWith<$Res> {
  _$TypeModelCopyWithImpl(this._value, this._then);

  final TypeModel _value;
  // ignore: unused_field
  final $Res Function(TypeModel) _then;

  @override
  $Res call({
    Object? isRequired = freezed,
    Object? isNullable = freezed,
    Object? defaultValue = freezed,
    Object? type = freezed,
    Object? name = freezed,
  }) {
    return _then(_value.copyWith(
      isRequired: isRequired == freezed
          ? _value.isRequired
          : isRequired // ignore: cast_nullable_to_non_nullable
              as bool,
      isNullable: isNullable == freezed
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
      defaultValue: defaultValue == freezed
          ? _value.defaultValue
          : defaultValue // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_TypeModelCopyWith<$Res> implements $TypeModelCopyWith<$Res> {
  factory _$$_TypeModelCopyWith(
          _$_TypeModel value, $Res Function(_$_TypeModel) then) =
      __$$_TypeModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {bool isRequired,
      bool isNullable,
      String? defaultValue,
      String type,
      String name});
}

/// @nodoc
class __$$_TypeModelCopyWithImpl<$Res> extends _$TypeModelCopyWithImpl<$Res>
    implements _$$_TypeModelCopyWith<$Res> {
  __$$_TypeModelCopyWithImpl(
      _$_TypeModel _value, $Res Function(_$_TypeModel) _then)
      : super(_value, (v) => _then(v as _$_TypeModel));

  @override
  _$_TypeModel get _value => super._value as _$_TypeModel;

  @override
  $Res call({
    Object? isRequired = freezed,
    Object? isNullable = freezed,
    Object? defaultValue = freezed,
    Object? type = freezed,
    Object? name = freezed,
  }) {
    return _then(_$_TypeModel(
      isRequired: isRequired == freezed
          ? _value.isRequired
          : isRequired // ignore: cast_nullable_to_non_nullable
              as bool,
      isNullable: isNullable == freezed
          ? _value.isNullable
          : isNullable // ignore: cast_nullable_to_non_nullable
              as bool,
      defaultValue: defaultValue == freezed
          ? _value.defaultValue
          : defaultValue // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TypeModel implements _TypeModel {
  const _$_TypeModel(
      {required this.isRequired,
      required this.isNullable,
      this.defaultValue,
      required this.type,
      required this.name});

  factory _$_TypeModel.fromJson(Map<String, dynamic> json) =>
      _$$_TypeModelFromJson(json);

  @override
  final bool isRequired;
  @override
  final bool isNullable;
  @override
  final String? defaultValue;
  @override
  final String type;
  @override
  final String name;

  @override
  String toString() {
    return 'TypeModel(isRequired: $isRequired, isNullable: $isNullable, defaultValue: $defaultValue, type: $type, name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TypeModel &&
            const DeepCollectionEquality()
                .equals(other.isRequired, isRequired) &&
            const DeepCollectionEquality()
                .equals(other.isNullable, isNullable) &&
            const DeepCollectionEquality()
                .equals(other.defaultValue, defaultValue) &&
            const DeepCollectionEquality().equals(other.type, type) &&
            const DeepCollectionEquality().equals(other.name, name));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(isRequired),
      const DeepCollectionEquality().hash(isNullable),
      const DeepCollectionEquality().hash(defaultValue),
      const DeepCollectionEquality().hash(type),
      const DeepCollectionEquality().hash(name));

  @JsonKey(ignore: true)
  @override
  _$$_TypeModelCopyWith<_$_TypeModel> get copyWith =>
      __$$_TypeModelCopyWithImpl<_$_TypeModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TypeModelToJson(this);
  }
}

abstract class _TypeModel implements TypeModel {
  const factory _TypeModel(
      {required final bool isRequired,
      required final bool isNullable,
      final String? defaultValue,
      required final String type,
      required final String name}) = _$_TypeModel;

  factory _TypeModel.fromJson(Map<String, dynamic> json) =
      _$_TypeModel.fromJson;

  @override
  bool get isRequired => throw _privateConstructorUsedError;
  @override
  bool get isNullable => throw _privateConstructorUsedError;
  @override
  String? get defaultValue => throw _privateConstructorUsedError;
  @override
  String get type => throw _privateConstructorUsedError;
  @override
  String get name => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_TypeModelCopyWith<_$_TypeModel> get copyWith =>
      throw _privateConstructorUsedError;
}

TypedefTemplateModel _$TypedefTemplateModelFromJson(Map<String, dynamic> json) {
  return _TypedefTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$TypedefTemplateModel {
  String get type => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  bool get hasFilter => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TypedefTemplateModelCopyWith<TypedefTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TypedefTemplateModelCopyWith<$Res> {
  factory $TypedefTemplateModelCopyWith(TypedefTemplateModel value,
          $Res Function(TypedefTemplateModel) then) =
      _$TypedefTemplateModelCopyWithImpl<$Res>;
  $Res call({String type, String name, bool hasFilter});
}

/// @nodoc
class _$TypedefTemplateModelCopyWithImpl<$Res>
    implements $TypedefTemplateModelCopyWith<$Res> {
  _$TypedefTemplateModelCopyWithImpl(this._value, this._then);

  final TypedefTemplateModel _value;
  // ignore: unused_field
  final $Res Function(TypedefTemplateModel) _then;

  @override
  $Res call({
    Object? type = freezed,
    Object? name = freezed,
    Object? hasFilter = freezed,
  }) {
    return _then(_value.copyWith(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: hasFilter == freezed
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$$_TypedefTemplateModelCopyWith<$Res>
    implements $TypedefTemplateModelCopyWith<$Res> {
  factory _$$_TypedefTemplateModelCopyWith(_$_TypedefTemplateModel value,
          $Res Function(_$_TypedefTemplateModel) then) =
      __$$_TypedefTemplateModelCopyWithImpl<$Res>;
  @override
  $Res call({String type, String name, bool hasFilter});
}

/// @nodoc
class __$$_TypedefTemplateModelCopyWithImpl<$Res>
    extends _$TypedefTemplateModelCopyWithImpl<$Res>
    implements _$$_TypedefTemplateModelCopyWith<$Res> {
  __$$_TypedefTemplateModelCopyWithImpl(_$_TypedefTemplateModel _value,
      $Res Function(_$_TypedefTemplateModel) _then)
      : super(_value, (v) => _then(v as _$_TypedefTemplateModel));

  @override
  _$_TypedefTemplateModel get _value => super._value as _$_TypedefTemplateModel;

  @override
  $Res call({
    Object? type = freezed,
    Object? name = freezed,
    Object? hasFilter = freezed,
  }) {
    return _then(_$_TypedefTemplateModel(
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: hasFilter == freezed
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_TypedefTemplateModel implements _TypedefTemplateModel {
  const _$_TypedefTemplateModel(
      {required this.type, required this.name, this.hasFilter = false});

  factory _$_TypedefTemplateModel.fromJson(Map<String, dynamic> json) =>
      _$$_TypedefTemplateModelFromJson(json);

  @override
  final String type;
  @override
  final String name;
  @override
  @JsonKey()
  final bool hasFilter;

  @override
  String toString() {
    return 'TypedefTemplateModel(type: $type, name: $name, hasFilter: $hasFilter)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TypedefTemplateModel &&
            const DeepCollectionEquality().equals(other.type, type) &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality().equals(other.hasFilter, hasFilter));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(type),
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(hasFilter));

  @JsonKey(ignore: true)
  @override
  _$$_TypedefTemplateModelCopyWith<_$_TypedefTemplateModel> get copyWith =>
      __$$_TypedefTemplateModelCopyWithImpl<_$_TypedefTemplateModel>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_TypedefTemplateModelToJson(this);
  }
}

abstract class _TypedefTemplateModel implements TypedefTemplateModel {
  const factory _TypedefTemplateModel(
      {required final String type,
      required final String name,
      final bool hasFilter}) = _$_TypedefTemplateModel;

  factory _TypedefTemplateModel.fromJson(Map<String, dynamic> json) =
      _$_TypedefTemplateModel.fromJson;

  @override
  String get type => throw _privateConstructorUsedError;
  @override
  String get name => throw _privateConstructorUsedError;
  @override
  bool get hasFilter => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_TypedefTemplateModelCopyWith<_$_TypedefTemplateModel> get copyWith =>
      throw _privateConstructorUsedError;
}

ListRepositoryTemplateModel _$ListRepositoryTemplateModelFromJson(
    Map<String, dynamic> json) {
  return _ListRepositoryTemplateModel.fromJson(json);
}

/// @nodoc
mixin _$ListRepositoryTemplateModel {
  String get api => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  dynamic get hasRequiredParam => throw _privateConstructorUsedError;
  bool get isInline => throw _privateConstructorUsedError;
  String get methodName => throw _privateConstructorUsedError;
  String get returnType => throw _privateConstructorUsedError;
  bool get hasFilter => throw _privateConstructorUsedError;
  List<ParamModel> get additionalParams => throw _privateConstructorUsedError;
  List<ParamModel> get filterParams => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ListRepositoryTemplateModelCopyWith<ListRepositoryTemplateModel>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListRepositoryTemplateModelCopyWith<$Res> {
  factory $ListRepositoryTemplateModelCopyWith(
          ListRepositoryTemplateModel value,
          $Res Function(ListRepositoryTemplateModel) then) =
      _$ListRepositoryTemplateModelCopyWithImpl<$Res>;
  $Res call(
      {String api,
      String name,
      dynamic hasRequiredParam,
      bool isInline,
      String methodName,
      String returnType,
      bool hasFilter,
      List<ParamModel> additionalParams,
      List<ParamModel> filterParams});
}

/// @nodoc
class _$ListRepositoryTemplateModelCopyWithImpl<$Res>
    implements $ListRepositoryTemplateModelCopyWith<$Res> {
  _$ListRepositoryTemplateModelCopyWithImpl(this._value, this._then);

  final ListRepositoryTemplateModel _value;
  // ignore: unused_field
  final $Res Function(ListRepositoryTemplateModel) _then;

  @override
  $Res call({
    Object? api = freezed,
    Object? name = freezed,
    Object? hasRequiredParam = freezed,
    Object? isInline = freezed,
    Object? methodName = freezed,
    Object? returnType = freezed,
    Object? hasFilter = freezed,
    Object? additionalParams = freezed,
    Object? filterParams = freezed,
  }) {
    return _then(_value.copyWith(
      api: api == freezed
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasRequiredParam: hasRequiredParam == freezed
          ? _value.hasRequiredParam
          : hasRequiredParam // ignore: cast_nullable_to_non_nullable
              as dynamic,
      isInline: isInline == freezed
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
      methodName: methodName == freezed
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: hasFilter == freezed
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      additionalParams: additionalParams == freezed
          ? _value.additionalParams
          : additionalParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      filterParams: filterParams == freezed
          ? _value.filterParams
          : filterParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
    ));
  }
}

/// @nodoc
abstract class _$$_ListRepositoryTemplateModelCopyWith<$Res>
    implements $ListRepositoryTemplateModelCopyWith<$Res> {
  factory _$$_ListRepositoryTemplateModelCopyWith(
          _$_ListRepositoryTemplateModel value,
          $Res Function(_$_ListRepositoryTemplateModel) then) =
      __$$_ListRepositoryTemplateModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {String api,
      String name,
      dynamic hasRequiredParam,
      bool isInline,
      String methodName,
      String returnType,
      bool hasFilter,
      List<ParamModel> additionalParams,
      List<ParamModel> filterParams});
}

/// @nodoc
class __$$_ListRepositoryTemplateModelCopyWithImpl<$Res>
    extends _$ListRepositoryTemplateModelCopyWithImpl<$Res>
    implements _$$_ListRepositoryTemplateModelCopyWith<$Res> {
  __$$_ListRepositoryTemplateModelCopyWithImpl(
      _$_ListRepositoryTemplateModel _value,
      $Res Function(_$_ListRepositoryTemplateModel) _then)
      : super(_value, (v) => _then(v as _$_ListRepositoryTemplateModel));

  @override
  _$_ListRepositoryTemplateModel get _value =>
      super._value as _$_ListRepositoryTemplateModel;

  @override
  $Res call({
    Object? api = freezed,
    Object? name = freezed,
    Object? hasRequiredParam = freezed,
    Object? isInline = freezed,
    Object? methodName = freezed,
    Object? returnType = freezed,
    Object? hasFilter = freezed,
    Object? additionalParams = freezed,
    Object? filterParams = freezed,
  }) {
    return _then(_$_ListRepositoryTemplateModel(
      api: api == freezed
          ? _value.api
          : api // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      hasRequiredParam: hasRequiredParam == freezed
          ? _value.hasRequiredParam
          : hasRequiredParam,
      isInline: isInline == freezed
          ? _value.isInline
          : isInline // ignore: cast_nullable_to_non_nullable
              as bool,
      methodName: methodName == freezed
          ? _value.methodName
          : methodName // ignore: cast_nullable_to_non_nullable
              as String,
      returnType: returnType == freezed
          ? _value.returnType
          : returnType // ignore: cast_nullable_to_non_nullable
              as String,
      hasFilter: hasFilter == freezed
          ? _value.hasFilter
          : hasFilter // ignore: cast_nullable_to_non_nullable
              as bool,
      additionalParams: additionalParams == freezed
          ? _value._additionalParams
          : additionalParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
      filterParams: filterParams == freezed
          ? _value._filterParams
          : filterParams // ignore: cast_nullable_to_non_nullable
              as List<ParamModel>,
    ));
  }
}

/// @nodoc

@JsonSerializable(explicitToJson: true)
class _$_ListRepositoryTemplateModel implements _ListRepositoryTemplateModel {
  const _$_ListRepositoryTemplateModel(
      {required this.api,
      required this.name,
      this.hasRequiredParam = false,
      this.isInline = false,
      required this.methodName,
      required this.returnType,
      this.hasFilter = false,
      final List<ParamModel> additionalParams = const [],
      final List<ParamModel> filterParams = const []})
      : _additionalParams = additionalParams,
        _filterParams = filterParams;

  factory _$_ListRepositoryTemplateModel.fromJson(Map<String, dynamic> json) =>
      _$$_ListRepositoryTemplateModelFromJson(json);

  @override
  final String api;
  @override
  final String name;
  @override
  @JsonKey()
  final dynamic hasRequiredParam;
  @override
  @JsonKey()
  final bool isInline;
  @override
  final String methodName;
  @override
  final String returnType;
  @override
  @JsonKey()
  final bool hasFilter;
  final List<ParamModel> _additionalParams;
  @override
  @JsonKey()
  List<ParamModel> get additionalParams {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_additionalParams);
  }

  final List<ParamModel> _filterParams;
  @override
  @JsonKey()
  List<ParamModel> get filterParams {
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filterParams);
  }

  @override
  String toString() {
    return 'ListRepositoryTemplateModel(api: $api, name: $name, hasRequiredParam: $hasRequiredParam, isInline: $isInline, methodName: $methodName, returnType: $returnType, hasFilter: $hasFilter, additionalParams: $additionalParams, filterParams: $filterParams)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ListRepositoryTemplateModel &&
            const DeepCollectionEquality().equals(other.api, api) &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality()
                .equals(other.hasRequiredParam, hasRequiredParam) &&
            const DeepCollectionEquality().equals(other.isInline, isInline) &&
            const DeepCollectionEquality()
                .equals(other.methodName, methodName) &&
            const DeepCollectionEquality()
                .equals(other.returnType, returnType) &&
            const DeepCollectionEquality().equals(other.hasFilter, hasFilter) &&
            const DeepCollectionEquality()
                .equals(other._additionalParams, _additionalParams) &&
            const DeepCollectionEquality()
                .equals(other._filterParams, _filterParams));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(api),
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(hasRequiredParam),
      const DeepCollectionEquality().hash(isInline),
      const DeepCollectionEquality().hash(methodName),
      const DeepCollectionEquality().hash(returnType),
      const DeepCollectionEquality().hash(hasFilter),
      const DeepCollectionEquality().hash(_additionalParams),
      const DeepCollectionEquality().hash(_filterParams));

  @JsonKey(ignore: true)
  @override
  _$$_ListRepositoryTemplateModelCopyWith<_$_ListRepositoryTemplateModel>
      get copyWith => __$$_ListRepositoryTemplateModelCopyWithImpl<
          _$_ListRepositoryTemplateModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ListRepositoryTemplateModelToJson(this);
  }
}

abstract class _ListRepositoryTemplateModel
    implements ListRepositoryTemplateModel {
  const factory _ListRepositoryTemplateModel(
      {required final String api,
      required final String name,
      final dynamic hasRequiredParam,
      final bool isInline,
      required final String methodName,
      required final String returnType,
      final bool hasFilter,
      final List<ParamModel> additionalParams,
      final List<ParamModel> filterParams}) = _$_ListRepositoryTemplateModel;

  factory _ListRepositoryTemplateModel.fromJson(Map<String, dynamic> json) =
      _$_ListRepositoryTemplateModel.fromJson;

  @override
  String get api => throw _privateConstructorUsedError;
  @override
  String get name => throw _privateConstructorUsedError;
  @override
  dynamic get hasRequiredParam => throw _privateConstructorUsedError;
  @override
  bool get isInline => throw _privateConstructorUsedError;
  @override
  String get methodName => throw _privateConstructorUsedError;
  @override
  String get returnType => throw _privateConstructorUsedError;
  @override
  bool get hasFilter => throw _privateConstructorUsedError;
  @override
  List<ParamModel> get additionalParams => throw _privateConstructorUsedError;
  @override
  List<ParamModel> get filterParams => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_ListRepositoryTemplateModelCopyWith<_$_ListRepositoryTemplateModel>
      get copyWith => throw _privateConstructorUsedError;
}

ParamModel _$ParamModelFromJson(Map<String, dynamic> json) {
  return _ParamModel.fromJson(json);
}

/// @nodoc
mixin _$ParamModel {
  String get param => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ParamModelCopyWith<ParamModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ParamModelCopyWith<$Res> {
  factory $ParamModelCopyWith(
          ParamModel value, $Res Function(ParamModel) then) =
      _$ParamModelCopyWithImpl<$Res>;
  $Res call({String param});
}

/// @nodoc
class _$ParamModelCopyWithImpl<$Res> implements $ParamModelCopyWith<$Res> {
  _$ParamModelCopyWithImpl(this._value, this._then);

  final ParamModel _value;
  // ignore: unused_field
  final $Res Function(ParamModel) _then;

  @override
  $Res call({
    Object? param = freezed,
  }) {
    return _then(_value.copyWith(
      param: param == freezed
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$$_ParamModelCopyWith<$Res>
    implements $ParamModelCopyWith<$Res> {
  factory _$$_ParamModelCopyWith(
          _$_ParamModel value, $Res Function(_$_ParamModel) then) =
      __$$_ParamModelCopyWithImpl<$Res>;
  @override
  $Res call({String param});
}

/// @nodoc
class __$$_ParamModelCopyWithImpl<$Res> extends _$ParamModelCopyWithImpl<$Res>
    implements _$$_ParamModelCopyWith<$Res> {
  __$$_ParamModelCopyWithImpl(
      _$_ParamModel _value, $Res Function(_$_ParamModel) _then)
      : super(_value, (v) => _then(v as _$_ParamModel));

  @override
  _$_ParamModel get _value => super._value as _$_ParamModel;

  @override
  $Res call({
    Object? param = freezed,
  }) {
    return _then(_$_ParamModel(
      param == freezed
          ? _value.param
          : param // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ParamModel implements _ParamModel {
  const _$_ParamModel(this.param);

  factory _$_ParamModel.fromJson(Map<String, dynamic> json) =>
      _$$_ParamModelFromJson(json);

  @override
  final String param;

  @override
  String toString() {
    return 'ParamModel(param: $param)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ParamModel &&
            const DeepCollectionEquality().equals(other.param, param));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(param));

  @JsonKey(ignore: true)
  @override
  _$$_ParamModelCopyWith<_$_ParamModel> get copyWith =>
      __$$_ParamModelCopyWithImpl<_$_ParamModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ParamModelToJson(this);
  }
}

abstract class _ParamModel implements ParamModel {
  const factory _ParamModel(final String param) = _$_ParamModel;

  factory _ParamModel.fromJson(Map<String, dynamic> json) =
      _$_ParamModel.fromJson;

  @override
  String get param => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_ParamModelCopyWith<_$_ParamModel> get copyWith =>
      throw _privateConstructorUsedError;
}
